import fs from 'node:fs'
import path from 'node:path'
import type { PackageResolver } from '../resolver'
import {
  calculateChecksum,
  readChecksumRecord,
  writeChecksumRecord,
  ensureDir,
  toVar,
  logGenerationResult,
  type GeneratorResult,
  createGeneratorResult,
} from '../utils'

export interface ModuleEntitiesOptions {
  resolver: PackageResolver
  quiet?: boolean
}

export async function generateModuleEntities(options: ModuleEntitiesOptions): Promise<GeneratorResult> {
  const { resolver, quiet = false } = options
  const result = createGeneratorResult()

  const outputDir = resolver.getOutputDir()
  const outFile = path.join(outputDir, 'entities.generated.ts')
  const checksumFile = path.join(outputDir, 'entities.generated.checksum')

  const mods = resolver.loadEnabledModules()
  const imports: string[] = []
  const entitySources: Array<{ importName: string; moduleId: string }> = []
  let n = 0

  for (const entry of mods) {
    const modId = entry.id
    const roots = resolver.getModulePaths(entry)
    const imp = resolver.getModuleImportBase(entry)
    const isAppModule = entry.from === '@app'

    // prefer app override data/, fallback to core data/, then legacy db/
    const appData = path.join(roots.appBase, 'data')
    const pkgData = path.join(roots.pkgBase, 'data')
    const appDb = path.join(roots.appBase, 'db')
    const pkgDb = path.join(roots.pkgBase, 'db')
    const bases = [appData, pkgData, appDb, pkgDb]
    const candidates = ['entities.override.ts', 'entities.ts', 'schema.ts']

    let found: { base: string; file: string } | null = null
    for (const base of bases) {
      for (const f of candidates) {
        const p = path.join(base, f)
        if (fs.existsSync(p)) {
          found = { base, file: f }
          break
        }
      }
      if (found) break
    }
    if (!found) continue

    const importName = `E_${toVar(modId)}_${n++}`
    const sub = path.basename(found.base) // 'data' or 'db'
    const fromApp = found.base.startsWith(roots.appBase)
    // For @app modules, use relative path to ensure it works both in Next.js and Node.js CLI context
    // From .mercato/generated/, the relative path to src/modules/ is ../src/modules/
    let relImport: string
    if (isAppModule && fromApp) {
      // From .mercato/generated/, go up two levels (../..) to reach the app root, then into src/modules/
      relImport = `../../src/modules/${modId}/${sub}/${found.file.replace(/\.ts$/, '')}`
    } else {
      const baseImport = fromApp ? imp.appBase : imp.pkgBase
      relImport = `${baseImport}/${sub}/${found.file.replace(/\.ts$/, '')}`
    }
    imports.push(`import * as ${importName} from '${relImport}'`)
    entitySources.push({ importName, moduleId: modId })
  }

  const output = `// AUTO-GENERATED by mercato generate entities
${imports.join('\n')}

function enhanceEntities(namespace: Record<string, unknown>, moduleId: string): any[] {
  return Object.entries(namespace)
    .filter(([, value]) => typeof value === 'function')
    .map(([exportName, value]) => {
      const entity = value as { entityName?: string }
      if (entity && typeof entity === 'function' && !Object.prototype.hasOwnProperty.call(entity, 'entityName')) {
        Object.defineProperty(entity, 'entityName', {
          value: \`\${moduleId}.\${exportName}\`,
          configurable: true,
          enumerable: false,
          writable: false,
        })
      }
      return entity
    })
}

export const entities = [
  ${entitySources.map(({ importName, moduleId }) => `...enhanceEntities(${importName}, '${moduleId}')`).join(',\n  ')}
]
`

  // Check if content has changed
  const newChecksum = calculateChecksum(output)
  let shouldWrite = true

  const existingRecord = readChecksumRecord(checksumFile)
  if (existingRecord && existingRecord.content === newChecksum) {
    shouldWrite = false
  }

  if (shouldWrite) {
    ensureDir(outFile)
    fs.writeFileSync(outFile, output)
    writeChecksumRecord(checksumFile, { content: newChecksum, structure: '' })
    result.filesWritten.push(outFile)
    if (!quiet) {
      logGenerationResult(path.relative(process.cwd(), outFile), true)
    }
  } else {
    result.filesUnchanged.push(outFile)
  }

  return result
}
