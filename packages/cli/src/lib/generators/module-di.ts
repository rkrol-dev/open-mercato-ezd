import fs from 'node:fs'
import path from 'node:path'
import type { PackageResolver } from '../resolver'
import {
  calculateChecksum,
  readChecksumRecord,
  writeChecksumRecord,
  ensureDir,
  toVar,
  logGenerationResult,
  type GeneratorResult,
  createGeneratorResult,
} from '../utils'

export interface ModuleDiOptions {
  resolver: PackageResolver
  quiet?: boolean
}

export async function generateModuleDi(options: ModuleDiOptions): Promise<GeneratorResult> {
  const { resolver, quiet = false } = options
  const result = createGeneratorResult()

  const outputDir = resolver.getOutputDir()
  const outFile = path.join(outputDir, 'di.generated.ts')
  const checksumFile = path.join(outputDir, 'di.generated.checksum')

  const mods = resolver.loadEnabledModules()
  const imports: string[] = []
  const registrars: string[] = []
  let i = 0

  for (const entry of mods) {
    const modId = entry.id
    const roots = resolver.getModulePaths(entry)
    const imp = resolver.getModuleImportBase(entry)
    const isAppModule = entry.from === '@app'

    const appDi = path.join(roots.appBase, 'di.ts')
    const pkgDi = path.join(roots.pkgBase, 'di.ts')
    const useApp = fs.existsSync(appDi)
    const usePkg = fs.existsSync(pkgDi)
    const importName = `D_${toVar(modId)}_${i++}`

    if (useApp) {
      // For @app modules, use relative path to work in both Next.js and Node.js CLI context
      // From .mercato/generated/, go up two levels (../..) to reach the app root, then into src/modules/
      const importPath = isAppModule ? `../../src/modules/${modId}/di` : `${imp.appBase}/di`
      imports.push(`import * as ${importName} from '${importPath}'`)
      registrars.push(`${importName}.register`)
    } else if (usePkg) {
      imports.push(`import * as ${importName} from '${imp.pkgBase}/di'`)
      registrars.push(`${importName}.register`)
    }
  }

  const output = `// AUTO-GENERATED by mercato generate di
${imports.join('\n')}

const diRegistrars = [
  ${registrars.join(',\n  ')}
].filter(Boolean) as (((c: any) => void)|undefined)[]

export { diRegistrars }
export default diRegistrars
`

  // Check if content has changed
  const newChecksum = calculateChecksum(output)
  let shouldWrite = true

  const existingRecord = readChecksumRecord(checksumFile)
  if (existingRecord && existingRecord.content === newChecksum) {
    shouldWrite = false
  }

  if (shouldWrite) {
    ensureDir(outFile)
    fs.writeFileSync(outFile, output)
    writeChecksumRecord(checksumFile, { content: newChecksum, structure: '' })
    result.filesWritten.push(outFile)
    if (!quiet) {
      logGenerationResult(path.relative(process.cwd(), outFile), true)
    }
  } else {
    result.filesUnchanged.push(outFile)
  }

  return result
}
