---
title: Analiza wdroÅ¼eniowa - Records (PrzesyÅ‚ka wpÅ‚ywajÄ…ca)
sidebar_position: 10
---

# Analiza wdroÅ¼eniowa: Records (PrzesyÅ‚ka wpÅ‚ywajÄ…ca / RPW / JRWA)

## Changelog
- **2026-02-10 (v8)**: Dodano scenariusz pobierania przesyÅ‚ek zewnÄ™trznych z systemÃ³w kancelaryjnych (EZD RP/eSODOK) oraz pola `external_rpw_number` i `external_document_ids` do obsÅ‚ugi synchronizacji zwrotnej.
- **2026-01-26 (v7)**: Dodano obsÅ‚ugÄ™ feature toggles dla wszystkich moduÅ‚Ã³w (records, correspondence_sources). Wprowadzono mechanizm wÅ‚Ä…czania/wyÅ‚Ä…czania funkcjonalnoÅ›ci na poziomie konfiguracji globalnej i per-tenant. Zaktualizowano dokumentacjÄ™ uÅ¼ytkownika o instrukcje aktywacji moduÅ‚Ã³w.
- **2026-01-26 (v6)**: Rozszerzono sekcjÄ™ integracji z `correspondence_sources` o kluczowe ustalenia biznesowe: automatyczne tworzenie przesyÅ‚ek w draft, mapowanie nadawcÃ³w z normalizacjÄ… identyfikatorÃ³w, obsÅ‚uga zaÅ‚Ä…cznikÃ³w jako records_documents, dwutorowa synchronizacja (manual + scheduled co 15 min), automatyczne wysyÅ‚anie UPD.
- **2026-01-26 (v5)**: Dodano sekcjÄ™ integracji z moduÅ‚em `correspondence_sources` w "Stan implementacji". Zlinkowano dokumentacjÄ™ integracji eDoreczenia. UspÃ³jniono opis pola `delivery_method` z implementacjÄ… automatycznego pobierania korespondencji.
- **2026-01-26 (v4)**: Aktualizacja odpowiedzi backlog Q4 â€“ doprecyzowano Q4-DOC-002 (brakowanie jako osobny status, nie tylko soft-delete), potwierdzono format RPW jako narzucony w MVP, potwierdzono `docs/docs` jako kanonicznÄ… strukturÄ™ dokumentacji.
- **2026-01-25 (v3)**: Dodano sekcjÄ™ "Stan implementacji" oraz szczegÃ³Å‚owe ustalenia dot. wzorcÃ³w UI/UX z analizy istniejÄ…cych moduÅ‚Ã³w (sales, catalog, customers). Rozszerzono dokumentacjÄ™ o konkretne przykÅ‚ady komponentÃ³w i konwencje architektoniczne.
- **2026-01-25 (v2)**: ZamkniÄ™cie backlogu Q3 â€“ rozstrzygniÄ™to kluczowe pytania (Q3-DOC-001/002/003, Q3-ACL-001/002, Q3-RPW-002/003, Q3-VAL-001/002/003, Q3-JRWA-001/002/003, Q3-INT-001/002, Q3-PERF-002). Decyzje wÅ‚Ä…czone do opisu w sekcjach 5â€“12. Utworzony nowy backlog Q4 (pytania pozostaÅ‚e i wynikajÄ…ce z Q3).
- **2026-01-26 (v1)**: ZamkniÄ™cie backlogu Q2 â€“ wszystkie 9 pytaÅ„ rozstrzygniÄ™te (Q2-RPW-001/002/003, Q2-SHIP-001/002, Q2-JRWA-001/002, Q2-UI-001, Q2-SEARCH-001). Decyzje wÅ‚Ä…czone do opisu w sekcjach 5â€“12. Utworzony backlog Q3 (30 pytaÅ„).
- **[wczeÅ›niej]**: Wersja wstÄ™pna dokumentu z backlogiem Q2.

---

## 1) Cel dokumentu
Ten dokument zbiera:
- zakres MVP i plan wdroÅ¼enia pierwszego wycinka moduÅ‚u `records`,
- zaÅ‚oÅ¼enia architektoniczne i techniczne (zgodne z konwencjami repozytorium),
- propozycjÄ™ modelu danych + API,
- listÄ™ **wÄ…tpliwoÅ›ci / pytaÅ„** (backlog decyzyjny), ktÃ³re bÄ™dziemy rozstrzygaÄ‡ po kolei.

Dokument jest celowo â€wdroÅ¼eniowyâ€: ma umoÅ¼liwiÄ‡ przejÅ›cie od opisu procesu (EZD) do implementacji w Open Mercato, z minimalnym ryzykiem przebudowy.

---

<a id="kontekst-domenowy"></a>
## 2) Kontekst domenowy (skrÃ³t)

:::info PowiÄ…zane dokumenty
- **Obiekt domenowy**: [PrzesyÅ‚ka wpÅ‚ywajÄ…ca](../obszary/archiwalno-kancelaryjne/obiekty/przesylka-wplywajaca)
- **Operacja**: [Rejestracja przesyÅ‚ki wpÅ‚ywajÄ…cej](../obszary/archiwalno-kancelaryjne/czynnosci/rejestracja-przesylki-wplywajacej)
- **SÅ‚ownik danych**: [Data Dictionary (MVP)](../mapping/openmercato-ezd/data-dictionary#przesyÅ‚ka-wpÅ‚ywajÄ…ca-incoming-shipment)
- **Mapowanie API**: [API Map - Incoming Shipments](../mapping/openmercato-ezd/api-map#proponowane-zasoby)

**Struktura dokumentacji**: Kanoniczna lokalizacja dokumentacji to `docs/docs` (nie `docs/`). Wszystkie Å›cieÅ¼ki w referencjach zakÅ‚adajÄ… ten katalog jako bazowy.
:::
W oparciu o dostarczone materiaÅ‚y:
- implementacjÄ™ zaczynamy od â€PrzesyÅ‚ki wpÅ‚ywajÄ…cejâ€ (rejestracja wpÅ‚ywu),
- numer RPW jest zwiÄ…zany z rejestracjÄ… przesyÅ‚ki (docelowo generator numerÃ³w),
- JRWA to klasyfikacja rzeczowa (drzewo klas + retencja), wykorzystywana pÃ³Åºniej m.in. do spraw/dokumentÃ³w.

---

## 3) Zakres MVP
### 3.1 Co wchodzi
1) **ModuÅ‚ `records`** w `packages/core/src/modules/records`.
2) Encje (poczÄ…tkowo minimalne):
   - `records_incoming_shipments` (PrzesyÅ‚ka wpÅ‚ywajÄ…ca)
   - `records_jrwa_classes` (JRWA)
3) Walidatory Zod:
   - create/update dla obu encji,
   - schemat query listy (paginacja + wyszukiwanie).
4) CRUD API (Next/route):
   - `GET/POST/PUT/DELETE` dla `incoming-shipments`
   - `GET/POST/PUT/DELETE` dla `jrwa-classes`
5) OpenAPI:
   - kaÅ¼dy route eksportuje `openApi` (wymÃ³g repo),
   - moduÅ‚owy helper `api/openapi.ts`.
6) `di.ts` (nawet jeÅ›li na razie pusty rejestrator).
7) Minimalne `search.ts`:
   - `formatResult` dla obu encji, aby wyniki Cmd+K nie pokazywaÅ‚y goÅ‚ych UUID.

### 3.2 Co nie wchodzi (na tym etapie)
- generowanie migracji i finalizacja schematu SQL (dopiero po zatwierdzeniu pÃ³l + indeksÃ³w),
- peÅ‚na logika numeracji RPW (generator + sekwencje + konfiguracja),
- encje â€kancelaria/officeâ€ jako osobny byt w `records` (kancelaria = komÃ³rka organizacyjna w strukturze organizacyjnej),
- sprawy i dokumenty (case/document), relacje i workflow.

---

## 4) Ograniczenia i zasady architektoniczne (z repo)
- ModuÅ‚y muszÄ… byÄ‡ **izomorficzne** i niezaleÅ¼ne: brak relacji ORM miÄ™dzy moduÅ‚ami (tylko FK jako `*_id`).
- Multi-tenant: wszystkie rekordy tenant-scoped muszÄ… mieÄ‡ `tenant_id` i (zwykle) `organization_id`.
- Walidacja wejÅ›Ä‡: Zod (bez rÄ™cznego SQL, bez interpolacji).
- API: CRUD przez `makeCrudRoute`, OpenAPI przez `createCrudOpenApiFactory`.
- Search: dla encji uÅ¼ywanych w Cmd+K wymagany `formatResult`.

---

<a id="model-danych"></a>
## 5) Proponowany model danych (draft)
<a id="incoming-shipments"></a>
### 5.1 `records_incoming_shipments`

:::note Single Source of Truth
PeÅ‚ny opis obiektu domenowego i jego metadanych znajduje siÄ™ w:
- [PrzesyÅ‚ka wpÅ‚ywajÄ…ca - obiekt domenowy](../obszary/archiwalno-kancelaryjne/obiekty/przesylka-wplywajaca)
- [SÅ‚ownik danych - PrzesyÅ‚ka wpÅ‚ywajÄ…ca](../mapping/openmercato-ezd/data-dictionary#przesyÅ‚ka-wpÅ‚ywajÄ…ca-incoming-shipment)
:::
Minimalny zestaw pÃ³l (MVP):
- `id: uuid`
- `tenant_id: uuid`
- `organization_id: uuid`
- `receiving_org_unit_id: uuid` â€“ ID komÃ³rki organizacyjnej (kancelarii) ze struktury organizacyjnej
- `receiving_org_unit_symbol: text` â€“ **symbol komÃ³rki organizacyjnej** (snapshot na przesyÅ‚ce; uÅ¼ywany jako `kanc_id` w RPW; decyzja Q2-RPW-001)
- `subject: text` â€“ temat (wymagane)
- `sender_id: uuid|null` â€“ ID nadawcy (referencja do moduÅ‚u customers; opcjonalne)
- `sender_display_name: text|null` â€“ nazwa nadawcy (wymagane jeÅ›li brak `sender_id`)
- `sender_anonymous: boolean` â€“ czy nadawca anonimowy (default: `false`)
  - **Zasada**: wymagane jest `sender_id` LUB `sender_display_name` (co najmniej jedno)
- `delivery_method: text` â€“ typ/sposÃ³b wpÅ‚ywu (wymagane; np. papier/ePUAP/e-mail). **Przy automatycznym pobieraniu korespondencji** wartoÅ›Ä‡ ustawiana automatycznie na typ ÅºrÃ³dÅ‚a (np. "edoreczenia-mock", "epuap", "ezdrp", "esodok") przez moduÅ‚ `correspondence_sources`. Zobacz: [Integracja eDoreczenia](/docs/integracje/edoreczenia/implementation#integration-with-records-module)
- `status: text` â€“ `draft` | `registered` (wymagane; default: `draft`)
- `received_at: timestamptz|null` â€“ data wpÅ‚ywu (wymagane najpÃ³Åºniej na etapie rejestracji)
- `rpw_number: text|null` â€“ numer RPW (nullable w `draft`, ustawiany wyÅ‚Ä…cznie w akcji â€Zarejestruj wpÅ‚ywâ€)
- `external_rpw_number: text|null` â€“ obcy numer RPW z systemu kancelaryjnego (np. EZD RP/eSODOK), przekazywany przy imporcie dla synchronizacji zwrotnej
- `external_document_ids: text[]` â€“ techniczne identyfikatory dokumentÃ³w/plikÃ³w w systemie ÅºrÃ³dÅ‚owym (np. GUID/ID pliku); domyÅ›lnie `[]`
- `attachment_ids: uuid[]` â€“ **powiÄ…zane zaÅ‚Ä…czniki** (relacja do `attachments`; default: `[]`)
  - **Phase 1 (obecna implementacja)**: PrzesyÅ‚ka bezpoÅ›rednio referencjonuje zaÅ‚Ä…czniki z moduÅ‚u `attachments`
  - **Phase 2 (planowana)**: Model zostanie rozszerzony do `document_ids` (relacja do `records.documents`, ktÃ³re same majÄ… `attachment_ids`)
  - Zobacz: [Integracja eDoreczenia - Phase 2](/docs/integracje/edoreczenia/implementation#future-enhancements) - obsÅ‚uga dokumentÃ³w jest w fazie planowania
  - W Phase 1: pole pozostaje puste (`[]`) - dokumenty sÄ… referencjonowane w polu `remarks` jako tekst
  - W Phase 2: wymagane bÄ™dzie co najmniej 1 dokument (decyzja Q2-SHIP-001, Q2-SHIP-002)
- `is_active: boolean`
- `created_at`, `updated_at`, `deleted_at`

**Integracja z zewnÄ™trznym systemem kancelaryjnym (EZD RP/eSODOK)**:
- PrzesyÅ‚ka moÅ¼e zostaÄ‡ pobrana juÅ¼ po rejestracji w systemie ÅºrÃ³dÅ‚owym, dlatego `external_rpw_number` przechowuje numer RPW z tamtego systemu.
- `external_document_ids` zapisuje techniczne identyfikatory dokumentÃ³w/plikÃ³w ÅºrÃ³dÅ‚owych, aby umoÅ¼liwiÄ‡ pÃ³ÅºniejszÄ… synchronizacjÄ™ zwrotnÄ….
- W tych przypadkach `delivery_method` wskazuje system ÅºrÃ³dÅ‚owy (np. `ezdrp`, `esodok`).

Proponowane indeksy (docelowo):
- `(tenant_id, organization_id)`
- `(tenant_id, organization_id, rpw_number)` â€“ unikalnoÅ›Ä‡ numeru w scope organizacji
- `(tenant_id, organization_id, receiving_org_unit_id)`

**Generator RPW** (decyzje Q2-RPW-001, Q2-RPW-002):
- Format: `RPW/{kanc_id}/{seq:5}/{yyyy}` â€“ **narzucony w MVP** (nie konfigurowalny)
- `kanc_id` = symbol komÃ³rki organizacyjnej (`receiving_org_unit_symbol`)
- Sekwencja `seq` jest **per organization + komÃ³rka + rok** (resetowana rocznie dla kaÅ¼dej kancelarii)
- Klucz sekwencji: `(organization_id, receiving_org_unit_id, year)`
- **Uwaga**: Format RPW jest sztywno okreÅ›lony na etapie MVP zgodnie z wymaganiami instrukcji kancelaryjnych. Ewentualna konfigurowalnoÅ›Ä‡ formatu moÅ¼e byÄ‡ rozwaÅ¼ona w przyszÅ‚ych iteracjach.

<a id="jrwa"></a>
### 5.2 `records_jrwa_classes`

:::note Single Source of Truth
PeÅ‚ny opis JRWA znajduje siÄ™ w:
- [JRWA - dokumentacja](../obszary/archiwalno-kancelaryjne/jrwa)
- [SÅ‚ownik danych - JRWA](../mapping/openmercato-ezd/data-dictionary#jrwa-klasa)
:::
Minimalny zestaw pÃ³l (MVP):
- `id: uuid`
- `tenant_id: uuid`
- `organization_id: uuid`
- `code: text` â€“ liczbowy (np. â€1234â€)
- `name: text`
- `parent_id: uuid|null` â€“ drzewo
- `retention_years: int|null`
- `retention_category: text|null` â€“ np. A/B/BE itd.
- `version: int` â€“ **wersja JRWA** (pole na klasie; decyzja Q2-JRWA-001)
  - Wersjonowanie realizowane przez pole `version` bezpoÅ›rednio na encji klasy
  - Brak osobnej encji `jrwa_versions` w MVP
- `is_active: boolean`
- `created_at`, `updated_at`, `deleted_at`

Proponowane indeksy (docelowo):
- `(tenant_id, organization_id, parent_id, code)` â€“ unikalnoÅ›Ä‡ wÄ™zÅ‚Ã³w w drzewie
- `(tenant_id, organization_id, version)`

**Import CSV** (decyzja Q2-JRWA-002, Q3-JRWA-001):
- Mapowanie `parent_id` przez **kod rodzica** z CSV
- Kolumny CSV: `code`, `name`, `parent_code`, `retention_years`, `retention_category`, `version`
- Proces importu musi rozwiÄ…zaÄ‡ kody rodzicÃ³w na UUID podczas wczytywania
- **Proces importu** (decyzja Q3-JRWA-001):
  - Import realizowany jako batch insert z walidacjÄ… (transakcja)
  - Walidacja przed importem: sprawdzenie poprawnoÅ›ci struktury CSV, unikalnoÅ›Ä‡ kodÃ³w, istnienie parent_code
  - BÅ‚Ä™dy w CSV (brak parent_code, duplikaty code) blokujÄ… caÅ‚y import z listÄ… bÅ‚Ä™dÃ³w
  - Import tworzy **nowÄ… wersjÄ™** (`version++`) â€“ stare rekordy archiwizowane (`is_active=false`)
  - MoÅ¼liwoÅ›Ä‡ edycji pojedynczych klas w aktualnej wersji (CRUD) â€“ nie wymusza importu
- **Kod JRWA unikalny** (decyzja Q3-JRWA-003):
  - `code` musi byÄ‡ **unikalny w ramach caÅ‚ego drzewa** (w scope organizacji + wersji)
  - Indeks unique: `(tenant_id, organization_id, version, code)`

<a id="documents"></a>
### 5.3 `records_documents`

:::note Single Source of Truth
PeÅ‚ny opis dokumentu znajduje siÄ™ w:
- [Dokument - obiekt domenowy](../obszary/archiwalno-kancelaryjne/obiekty/dokument)
- [SÅ‚ownik danych - Dokument](../mapping/openmercato-ezd/data-dictionary#dokument)
:::
Minimalny zestaw pÃ³l (MVP) â€“ **decyzja Q3-DOC-001**:
- `id: uuid`
- `tenant_id: uuid`
- `organization_id: uuid`
- `title: text` â€“ tytuÅ‚ dokumentu (wymagane)
- `kind: text` â€“ rodzaj dokumentu, np. `pismo`, `notatka`, `umowa` (wymagane)
- `access_level: text` â€“ poziom dostÄ™pu: `public`, `partial`, `restricted` (wymagane)
- `received_at: timestamptz|null` â€“ data wpÅ‚ywu dokumentu (opcjonalne)
- `document_date: date|null` â€“ data pisma/dokumentu (opcjonalne)
- `document_sign: text|null` â€“ znak pisma/sprawy na dokumencie (opcjonalne)
- `case_id: uuid|null` â€“ relacja do sprawy (opcjonalne)
- `incoming_shipment_id: uuid|null` â€“ relacja do przesyÅ‚ki wpÅ‚ywajÄ…cej (opcjonalne)
- `outgoing_shipment_id: uuid|null` â€“ relacja do przesyÅ‚ki wychodzÄ…cej (opcjonalne)
- `attachment_ids: uuid[]` â€“ **referencje do zaÅ‚Ä…cznikÃ³w** (moduÅ‚ `attachments`; opcjonalne)
- `disposal_status: text|null` â€“ **status brakowania** (decyzja Q4-DOC-002): `null` (domyÅ›lnie), `pending_disposal`, `disposed`
- `disposal_date: date|null` â€“ data brakowania (opcjonalne; wypeÅ‚niane przy `disposal_status = 'disposed'`)
- `disposal_protocol_number: text|null` â€“ numer protokoÅ‚u brakowania (opcjonalne)
- `disposal_approved_by: uuid|null` â€“ ID uÅ¼ytkownika zatwierdzajÄ…cego brakowanie (opcjonalne)
- `is_active: boolean`
- `created_at`, `updated_at`, `deleted_at`

**Uwagi** (decyzje Q3-DOC-001, Q3-DOC-003, Q4-DOC-002):
- `records.documents` to **encja metadanych kancelaryjnych/archiwalnych**
- Fizyczne pliki przechowywane w module `attachments` (core)
- **Typ/format pliku NIE jest polem dokumentu** â€“ pochodzi z `attachments.mime_type`
- Relacja przesyÅ‚kaâ†”dokument: `incoming_shipments.document_ids` wskazuje na dokumenty
- **1 dokument = 1 przesyÅ‚ka** (decyzja Q3-DOC-003) â€“ dokumenty nie sÄ… wspÃ³Å‚dzielone miÄ™dzy przesyÅ‚kami
- Dokument moÅ¼e mieÄ‡ zarÃ³wno `incoming_shipment_id` jak i `outgoing_shipment_id` (dokument wpÅ‚ywajÄ…cy + odpowiedÅº wychodzÄ…ca)
- **Brakowanie vs soft-delete** (Q4-DOC-002): `disposal_status` oznacza formalne brakowanie zgodnie z procedurami archiwalnymi, podczas gdy `deleted_at` jest uÅ¼ywany do usuwania roboczych/bÅ‚Ä™dnych dokumentÃ³w
- Workflow/akceptacje/podpis: **pola rozszerzajÄ…ce** â€“ nie blokujÄ… MVP

Proponowane indeksy (docelowo):
- `(tenant_id, organization_id)`
- `(tenant_id, organization_id, incoming_shipment_id)`
- `(tenant_id, organization_id, case_id)`

---

<a id="api"></a>
## 6) API (MVP)

:::note API Mapping
SzczegÃ³Å‚owe mapowanie API znajduje siÄ™ w:
- [Mapowanie API (CRUD)](../mapping/openmercato-ezd/api-map)
:::
### 6.1 Endpointy
- `GET /api/records/incoming-shipments`
- `POST /api/records/incoming-shipments`
- `PUT /api/records/incoming-shipments`
- `DELETE /api/records/incoming-shipments?id=<uuid>`

Akcja procesowa (poza CRUD):
- `POST /api/records/incoming-shipments/{id}/register` â€“ â€Zarejestruj wpÅ‚ywâ€ (nadaje RPW, wymusza komplet danych, ustawia status `registered`)
  - **Idempotencja** (decyzja Q2-RPW-003): jeÅ›li przesyÅ‚ka juÅ¼ ma status `registered`, zwraca 409 Conflict
  - Akcja nie jest idempotentna â€“ prÃ³ba ponownej rejestracji jest traktowana jako bÅ‚Ä…d

- `GET /api/records/jrwa-classes`
- `POST /api/records/jrwa-classes`
- `PUT /api/records/jrwa-classes`
- `DELETE /api/records/jrwa-classes?id=<uuid>`

Akcja procesowa dla JRWA:
- `POST /api/records/jrwa-classes/import` â€“ import CSV (decyzje Q3-JRWA-001, Q3-JRWA-002)
  - Walidacja struktury CSV przed importem
  - Batch insert w transakcji
  - Tworzy nowÄ… wersjÄ™ (`version++`), archiwizuje starÄ… (`is_active=false`)
  - BÅ‚Ä™dy blokujÄ… caÅ‚y import z raportem bÅ‚Ä™dÃ³w

- `GET /api/records/documents`
- `POST /api/records/documents`
- `PUT /api/records/documents`
- `DELETE /api/records/documents?id=<uuid>`

**Uwaga o walidacji rejestracji wpÅ‚ywu** (decyzje Q3-DOC-002, Q3-VAL-001, Q3-RPW-002):
- `document_ids` jest niepustÄ… tablicÄ… UUID
- Wszystkie wskazane dokumenty istniejÄ…, nie sÄ… usuniÄ™te i sÄ… w scope `tenant_id`/`organization_id`
- Wymagane pola: `subject`, `sender_name`, `delivery_method`, `received_at`, `receiving_org_unit_symbol`
- JeÅ›li `receiving_org_unit_symbol` jest NULL/puste â€“ bÅ‚Ä…d walidacji
- JeÅ›li brak dokumentÃ³w lub sÄ… usuniÄ™te â€“ bÅ‚Ä…d 400 z listÄ… brakujÄ…cych ID

**Uwaga o edycji przesyÅ‚ek** (decyzja Q3-VAL-002, Q3-RPW-003):
- PrzesyÅ‚ki w statusie `registered` **moÅ¼na edytowaÄ‡** (kaÅ¼de pole oprÃ³cz RPW)
- RPW **nie podlega edycji** po rejestracji â€“ immutable (hard constraint)
- Wszystkie zmiany logowane do audit log

**Statusy przesyÅ‚ek** (decyzja Q3-VAL-003):
- **MVP (zaimplementowane)**: `draft`, `registered`
  - `draft` â€“ przesyÅ‚ka utworzona, ale nie zarejestrowana (brak RPW)
  - `registered` â€“ przesyÅ‚ka zarejestrowana (ma nadany RPW)
- **Planowane w przyszÅ‚oÅ›ci**: `archived`
  - Status koÅ„cowy dla zamkniÄ™tych/zarchiwizowanych przesyÅ‚ek
  - Wymaga dodatkowej logiki biznesowej i walidacji
  - NIE jest czÄ™Å›ciÄ… obecnej implementacji MVP

### 6.2 Listowanie
**Decyzja Q3-PERF-002**: uÅ¼ywamy QueryEngine od razu (nie ORM fallback).
- jawne `entityId` + `fields`,
- filtrowanie/sortowanie zgodnie z Q3-PERF-001,
- custom fields itd.


---

## 7) Uprawnienia (ACL)
**Decyzje Q3-ACL-001, Q3-ACL-002**: przyjÄ™ty model uprawnieÅ„ z podziaÅ‚em view/manage.

### 7.1 PrzesyÅ‚ki wpÅ‚ywajÄ…ce
- `records.incoming_shipments.view` â€“ odczyt przesyÅ‚ek
- `records.incoming_shipments.manage` â€“ zarzÄ…dzanie (create/edit/delete)
- `records.incoming_shipments.register` â€“ rejestracja wpÅ‚ywu (osobno; wymaga dodatkowych uprawnieÅ„)

Uzasadnienie: uproszczenie zarzÄ…dzania rolami przy zachowaniu moÅ¼liwoÅ›ci rozdzielenia uprawnienia do rejestracji.

### 7.2 JRWA
- `records.jrwa_classes.view` â€“ odczyt klas JRWA (szeroko; wiÄ™kszoÅ›Ä‡ uÅ¼ytkownikÃ³w)
- `records.jrwa_classes.manage` â€“ administracja (create/edit/delete pojedynczych klas)
- `records.jrwa_classes.import` â€“ import CSV (osobno; potencjalnie destrukcyjna operacja masowa)

Uzasadnienie: rozdzielenie `import` od `manage` pozwala daÄ‡ adminom edycjÄ™ rÄ™cznÄ… bez prawa do masowych zmian.

### 7.3 Dokumenty
- `records.documents.view` â€“ odczyt dokumentÃ³w
- `records.documents.manage` â€“ zarzÄ…dzanie dokumentami (create/edit/delete)

DostÄ™p do zaÅ‚Ä…cznikÃ³w kontrolowany przez:
1. Uprawnienia do gÅ‚Ã³wnego wÅ‚aÅ›ciciela (przesyÅ‚ka/sprawa/dokument)
2. Poziom dostÄ™pu dokumentu (`access_level`)
3. Status wÅ‚aÅ›ciciela (np. `read-only` dla sprawy)


---

## 8) OpenAPI
Wszystkie routeâ€™y muszÄ… eksportowaÄ‡ `openApi`.
- Dla CRUD uÅ¼ywamy moduÅ‚owego wrappera `createRecordsCrudOpenApi` (analogicznie do customers/sales/catalog).

---

## 9) Search (Cmd+K)
MVP: definicje w `records/search.ts`:
- `formatResult` dla `incoming_shipments` (np. tytuÅ‚ / RPW),
- `formatResult` dla `jrwa_classes` (np. `code â€” name`).

**Strategia search** (decyzja Q2-SEARCH-001):
- UÅ¼ywamy **tokens** (nie fulltext)
- Pola do indeksowania: `subject`, `sender_name`, `rpw_number` dla przesyÅ‚ek; `code`, `name` dla JRWA
- TytuÅ‚ wyniku: dla przesyÅ‚ek â€“ `subject` + `rpw_number`; dla JRWA â€“ `code â€” name`

Uwaga: `entityId` w search musi byÄ‡ spÃ³jne z rejestrem encji (generator). Decyzja: uruchamiamy generator od razu.

---

## 10) Migracje i generator moduÅ‚Ã³w
Na ten etap: **nie generujemy migracji**.

JednoczeÅ›nie: **uruchamiamy generator moduÅ‚Ã³w od razu** (Å¼eby mieÄ‡ `E.records.*`, registries i spÃ³jne `entityId` dla search/indexer).

Plan:
1) Zatwierdzamy model pÃ³l + unikalnoÅ›ci + indeksy.
2) Dopiero wtedy aktualizujemy encje MikroORM.
3) Generujemy migracje poleceniem repo (`npm run db:generate`).

---

## 11) Strategia wdroÅ¼enia (kolejnoÅ›Ä‡ prac)
1) Scaffold moduÅ‚u `records` (pliki + kompilacja): encje, validators, routes, openapi, di, search.
2) Generator: `modules:prepare` i dopiÄ™cie `entityId`/search.
3) Smoke test API (lokalnie): create/list/update/delete + akcja `register`.
4) Doprecyzowanie RPW:
  - implementacja generatora numerÃ³w (wzorowana na `salesDocumentNumberGenerator`),
  - format staÅ‚y: `RPW/{kanc_id}/{seq:5}/{yyyy}` (sekwencja resetowana rocznie),
  - nadawanie RPW wyÅ‚Ä…cznie w akcji â€Zarejestruj wpÅ‚ywâ€.
5) Doprecyzowanie JRWA:
  - import CSV,
  - wersjonowanie,
  - unikalnoÅ›Ä‡ `(parent_id, code)`.
6) Migracje.
7) UI/backoffice (decyzja Q2-UI-001):
  - Lista przesyÅ‚ek wpÅ‚ywajÄ…cych (tabela z kolumnami: RPW, temat, nadawca, data wpÅ‚ywu, status)
  - Formularz create/edit przesyÅ‚ki
  - Przycisk â€Zarejestruj wpÅ‚yw" (Cmd/Ctrl+Enter) dostÄ™pny dla przesyÅ‚ek w statusie `draft`
  - Lista klas JRWA (drzewo lub tabela z kolumnami: kod, nazwa, retencja)
  - Formularz create/edit klasy JRWA

---

## 12) Ryzyka i puÅ‚apki (po rozstrzygniÄ™ciach Q3)
- ~~`kanc_id` w numerze RPW~~: **ROZSTRZYGNIÄ˜TE** (Q2-RPW-001, Q2-RPW-002, Q3-RPW-002)
  - UÅ¼ywamy `receiving_org_unit_symbol` jako `kanc_id` w formacie RPW
  - Sekwencja per organization + komÃ³rka + rok
  - Walidacja wymagajÄ…ca `receiving_org_unit_symbol` przed rejestracjÄ…
- ~~JRWA import CSV + wersjonowanie~~: **ROZSTRZYGNIÄ˜TE** (Q2-JRWA-001, Q2-JRWA-002, Q3-JRWA-001/002/003)
  - Pole `version` bezpoÅ›rednio na klasie
  - Import CSV mapuje parent przez kod rodzica
  - Batch insert w transakcji, archiwizacja starej wersji
  - Kod JRWA unikalny w ramach caÅ‚ego drzewa
- ~~ZaÅ‚Ä…czniki wymagane w MVP~~: **ROZSTRZYGNIÄ˜TE** (Q2-SHIP-001, Q2-SHIP-002, Q3-DOC-001/002/003)
  - PrzesyÅ‚ka powiÄ…zana z dokumentami (`records.documents`)
  - WymÃ³g co najmniej 1 dokumentu walidowany w akcji `register`
  - Dokumenty jako encja metadanych + attachments dla fizycznych plikÃ³w
  - 1 dokument = 1 przesyÅ‚ka (nie wspÃ³Å‚dzielone)
- ~~Uprawnienia ACL~~: **ROZSTRZYGNIÄ˜TE** (Q3-ACL-001, Q3-ACL-002)
  - Model view/manage dla wszystkich encji
  - Osobne uprawnienie `register` dla przesyÅ‚ek i `import` dla JRWA
- ~~Walidacje i workflow~~: **ROZSTRZYGNIÄ˜TE** (Q3-VAL-001/002/003)
  - PeÅ‚na lista wymaganych pÃ³l w akcji `register`
  - MoÅ¼liwoÅ›Ä‡ edycji przesyÅ‚ek po rejestracji (oprÃ³cz RPW)
  - Statusy: `draft`, `registered` (zaimplementowane); `archived` planowany w przyszÅ‚oÅ›ci
- ~~Generator/sekwencje~~: implementacja generatora RPW wedÅ‚ug wzorca `salesDocumentNumberGenerator` (Q3-RPW-001) â€“ **ROZSTRZYGNIÄ˜TE** (Q4-RPW-001)
- ~~Integracje moduÅ‚owe~~: integracje z `directory` / `attachments` / `customers` â€“ **ROZSTRZYGNIÄ˜TE** (Q4-INT-001/002/003)

---

## 13) Backlog wÄ…tpliwoÅ›ci Q4 (po rozstrzygniÄ™ciu Q3)
Wszystkie pytania Q3 dotyczÄ…ce dokumentÃ³w, uprawnieÅ„, walidacji i JRWA zostaÅ‚y **rozstrzygniÄ™te** i wÅ‚Ä…czone do opisu w sekcjach 5â€“12.

PoniÅ¼ej lista **pozostaÅ‚ych** i **nowych** pytaÅ„ wynikajÄ…cych z podjÄ™tych decyzji Q3:

### A) Implementacja generatora RPW
- ~~Q4-RPW-001 (P0)~~: Jak dokÅ‚adnie zaimplementowaÄ‡ generator sekwencji dla RPW? â€“ **ROZSTRZYGNIÄ˜TE**
  - Wzorujemy siÄ™ na `salesDocumentNumberGenerator`, ale jako osobna implementacja w module `records` (inne scope i format).
  - Sekwencje trzymamy w osobnej tabeli `records_rpw_sequences` z unikalnoÅ›ciÄ…: `(tenant_id, organization_id, receiving_org_unit_id, year)`.
  - Claim sekwencji robimy atomowo w PostgreSQL: `INSERT ... ON CONFLICT ... DO UPDATE ... RETURNING` (bez optimistic locking).
  - Thread-safety: rejestracja w transakcji + blokada przesyÅ‚ki (`PESSIMISTIC_WRITE`) + atomowy increment sekwencji; rollback transakcji nie zuÅ¼ywa numeru.
  - Endpoint diagnostyczny (podglÄ…d/reset) jest opcjonalny; jeÅ›li bÄ™dzie potrzebny, wzorzec jak w `sales` (peek + set next).

- **Q4-RPW-002 (P1)**: Jak obsÅ‚uÅ¼yÄ‡ migracjÄ™ historycznych numerÃ³w RPW?
  - jeÅ›li organizacja ma juÅ¼ istniejÄ…ce przesyÅ‚ki z RPW, jak zainicjowaÄ‡ sekwencjÄ™?
  - czy sekwencja startuje od max(rpw_sequence) + 1 czy od nowa?
  - potrzebna komenda administracyjna do synchronizacji sekwencji?
  - decyzja: numery migrowane muszÄ… pozostaÄ‡ identyczne (zostaÅ‚y naniesione na dokument).

- ~~Q4-RPW-002 (P1)~~: Jak obsÅ‚uÅ¼yÄ‡ migracjÄ™ historycznych numerÃ³w RPW? â€“ **ROZSTRZYGNIÄ˜TE**
  - `rpw_number` jest polem â€prezentacyjnymâ€ i podczas migracji **musi pozostaÄ‡ identyczny** wzglÄ™dem ÅºrÃ³dÅ‚a (bez dopisywania prefiksÃ³w/sufiksÃ³w).
  - Oznaczenie organizacji ÅºrÃ³dÅ‚owej dodajemy jako osobne metadane (nie w `rpw_number`), np. `rpw_origin_org_code` (text) lub `rpw_origin_organization_id` (uuid).
    - â€Idealnieâ€: przy migracji ustawiamy `rpw_origin_org_code` na stabilny identyfikator organizacji w systemie ÅºrÃ³dÅ‚owym (np. skrÃ³t).
    - UI/Search moÅ¼e prezentowaÄ‡ pochodzenie obok numeru (np. `RPW/.../2024 Â· ÅºrÃ³dÅ‚o: <code>`), ale sam numer pozostaje bez zmian.
  - Podczas migracji uzupeÅ‚niamy `rpw_sequence` na przesyÅ‚ce (na podstawie ÅºrÃ³dÅ‚a lub przez parsowanie z `rpw_number`, jeÅ›li pasuje do formatu `RPW/{kanc_id}/{seq}/{yyyy}`).
  - Po migracji wykonujemy rzadkÄ… operacjÄ™ administracyjnÄ… synchronizacji sekwencji:
    - Komenda/akcja admin wylicza `max(rpw_sequence)` w grupach `(tenant_id, organization_id, receiving_org_unit_id, year)` i ustawia `records_rpw_sequences.current_value = maxSeq`.
    - Aktualizacja jest idempotentna: `current_value = greatest(current_value, maxSeq)`.
    - NastÄ™pny numer generatora startuje od `maxSeq + 1` (a dla scope bez historii â€“ od `1`).


### B) Dokumenty: szczegÃ³Å‚y implementacji
- **Q4-DOC-001 (P0)**: Jak implementujemy relacjÄ™ dokumentâ†’attachment?
  - czy `attachment_ids: uuid[]` czy tablica obiektÃ³w z dodatkowymi metadanymi?
  - czy walidujemy istnienie attachmentÃ³w przy zapisie dokumentu?
  - jak obsÅ‚ugujemy upload plikÃ³w: osobny endpoint czy integracja w CRUD dokumentu?
  - wzorzec API: `POST /documents` z `multipart/form-data` czy `POST /documents` + `POST /documents/{id}/attachments`?

- **Q4-DOC-002 (P1)**: Jak implementujemy â€usuniÄ™cieâ€ dokumentu (brakowanie vs `DELETE`) w kontekÅ›cie RPW i skÅ‚adu chronologicznego?
- ~~Q4-DOC-002 (P1)~~: Jak implementujemy â€usuniÄ™cie" dokumentu (brakowanie vs `DELETE`) w kontekÅ›cie RPW i skÅ‚adu chronologicznego? â€“ **ROZSTRZYGNIÄ˜TE**
  - **Zasada**: dokumentÃ³w bÄ™dÄ…cych czÄ™Å›ciÄ… ewidencji (RPW / skÅ‚ad chronologiczny) **nie usuwamy** przez standardowy `DELETE`.
    - Dokument â€ma RPW" w praktyce oznacza: jest powiÄ…zany z przesyÅ‚kÄ… wpÅ‚ywajÄ…cÄ…, ktÃ³ra ma nadany numer RPW (`incoming_shipment.status = registered` i `rpw_number != null`).
    - Dokument â€jest w skÅ‚adzie chronologicznym" oznacza: ma aktywne lub historyczne przypisanie lokalizacji (rejestracja chronologiczna / assignments).
  - **WÅ‚aÅ›ciwa Å›cieÅ¼ka**: **brakowanie jako osobny status** (z protokoÅ‚em/zgodÄ…, odnotowaniem w ewidencji i audytem), zgodnie z zasadami archiwum zakÅ‚adowego.
    - **Model danych**: dodanie pola `disposal_status` do dokumentu z wartoÅ›ciami: `null` (domyÅ›lnie), `disposed`, `pending_disposal`.
    - Dodatkowe pola metadanych brakowania: `disposal_date`, `disposal_protocol_number`, `disposal_approved_by`.
    - **RÃ³Å¼nica vs soft-delete**: `deleted_at` jest uÅ¼ywany do standardowego usuwania (roboczych/bÅ‚Ä™dnych dokumentÃ³w), natomiast `disposal_status` oznacza formalne brakowanie zgodnie z procedurami archiwalnymi.
    - Dokument z `disposal_status = 'disposed'` pozostaje w systemie (audytowalny), ale nie jest wyÅ›wietlany na standardowych listach i nie moÅ¼e byÄ‡ doÅ‚Ä…czany do nowych przesyÅ‚ek.
  - **`DELETE` dozwolony tylko w ograniczonych sytuacjach** ("bÅ‚Ä…d/roboczy dokument"):
    - dokument **nie jest** referencjonowany przez Å¼adnÄ… przesyÅ‚kÄ™ (nie wystÄ™puje w `incoming_shipments.document_ids` i nie ma `incoming_shipment_id`/`outgoing_shipment_id`),
    - dokument **nie jest** ujÄ™ty w skÅ‚adzie chronologicznym (brak przypisaÅ„ lokalizacji),
    - dokument **nie jest** powiÄ…zany ze sprawÄ… (`case_id = null`),
    - dokument **nie jest** elementem procesu wymagajÄ…cego retencji/archiwizacji (w praktyce: brak rejestracji RPW i brak rejestracji chronologicznej).
    - W pozostaÅ‚ych przypadkach: `DELETE` zwraca bÅ‚Ä…d (np. 409) z komunikatem "wymagane brakowanie".
  - **WpÅ‚yw na walidacjÄ™ `register`**: `register` wymaga, aby wszystkie `document_ids` istniaÅ‚y i miaÅ‚y `deleted_at = null` oraz `disposal_status IN (null, 'pending_disposal')` (dokumenty w trakcie brakowania nie mogÄ… byÄ‡ rejestrowane).
  - **API**: dedykowany endpoint `POST /api/records/documents/{id}/dispose` do inicjowania procedury brakowania (z walidacjÄ… uprawnieÅ„ i wymaganych metadanych).

- **Q4-DOC-003 (P2)**: Czy dokumenty potrzebujÄ… wÅ‚asnej numeracji?
  - czy dokument ma pole `document_number` generowane automatycznie?
  - czy numeracja jest per organizacja czy globalna?
  - czy numeracja jest obligatoryjna czy opcjonalna (zaleÅ¼na od typu dokumentu)?
  - decyzja: nie, dokument nie potrzebuje wÅ‚asnej numeracji.

- ~~Q4-DOC-004 (P2)~~: Jak obsÅ‚ugujemy rÃ³Å¼ne typy dokumentÃ³w (`kind`)? â€“ **ROZSTRZYGNIÄ˜TE**
  - `kind` jest **konfigurowalnym sÅ‚ownikiem** (per `organization_id`), a nie hard-coded enumem w kodzie.
  - Seed domyÅ›lny (MVP): `pismo`, `notatka`, `umowa`, `protokÃ³Å‚`, `decyzja`, `postanowienie`, `faktura`, `wniosek`, `skarga`, `opinia`, `prezentacja`.
  - Walidacja MVP: `kind` = **niepusty string**; opcjonalnie (feature flag / konfiguracja Å›rodowiska) walidacja, Å¼e wartoÅ›Ä‡ naleÅ¼y do zseedowanej listy.
  - RÃ³Å¼ne wymagane pola per `kind`: realizujemy przez **custom fields** (per `entityId` + ewentualnie per â€wariantâ€) â€“ nie blokuje MVP.

### C) Integracje moduÅ‚owe
- ~~Q4-INT-001 (P0)~~: Jak integrujemy siÄ™ z moduÅ‚em `directory` (struktura organizacyjna)? â€“ **ROZSTRZYGNIÄ˜TE**
  - **MVP: bez cache w `records`** â€“ UI pobiera strukturÄ™ z API `directory` (hierarchia jednostek), backend nie utrzymuje wÅ‚asnej kopii.
  - **Model danych**: na przesyÅ‚ce trzymamy `receiving_org_unit_id` (referencja) oraz `receiving_org_unit_symbol` jako **snapshot** (uÅ¼ywany jako `kanc_id` w RPW).
  - **Å¹rÃ³dÅ‚o symbolu**: symbol kancelarii jest wÅ‚asnoÅ›ciÄ… `directory` (np. jako custom field/konfiguracja na jednostce). `records` jedynie snapshotuje wartoÅ›Ä‡.
  - **Walidacja create/update**: walidujemy, Å¼e `receiving_org_unit_id` istnieje i jest w scope `tenant_id`/`organization_id` w momencie zapisu.
  - **Zmiany po rejestracji**: po nadaniu RPW `receiving_org_unit_id` i `receiving_org_unit_symbol` traktujemy jako **immutable** (zmiana wymagaÅ‚aby zmiany numeru RPW).
  - **UsuniÄ™cie/dezaktywacja jednostki**: nie blokuje istniejÄ…cych przesyÅ‚ek; snapshot (`receiving_org_unit_symbol`) pozostaje historycznym ÅºrÃ³dÅ‚em prawdy.

- ~~Q4-INT-002 (P0)~~: Jak integrujemy siÄ™ z moduÅ‚em `attachments`? â€“ **ROZSTRZYGNIÄ˜TE**
  - **ReuÅ¼ywamy istniejÄ…ce API `attachments`** (upload/list/metadata/transfer); `records` nie tworzy alternatywnego storage.
  - **Owner/primary link**: podstawowym wÅ‚aÅ›cicielem pliku jest encja domenowa (najczÄ™Å›ciej `records.document`). W `attachments` owner jest wyraÅ¼ony przez `entityId` + `recordId`.
  - **Relacje w `records`**: dokument ma `attachment_ids`, przesyÅ‚ka ma `document_ids`; unikamy duplikowania â€wÅ‚aÅ›cicielaâ€ na kilku poziomach (pliki przypinamy do dokumentu, a nie do przesyÅ‚ki).
  - **RBAC i access level**: dostÄ™p do plikÃ³w wynika z uprawnieÅ„ do wÅ‚aÅ›ciciela (np. `records.documents.view/manage`) oraz `access_level` dokumentu.
  - **Rekomendacja techniczna**: wystawiÄ‡ wrapper endpointy w `records` dla operacji na plikach (list/upload/delete/transfer), ktÃ³re najpierw egzekwujÄ… reguÅ‚y `records` (ACL + `access_level`), a dopiero potem delegujÄ… do `attachments`.
  - **Metadane plikÃ³w**: specyficzne flagi (np. â€gÅ‚Ã³wny dokumentâ€, â€jakoÅ›Ä‡ skanuâ€, OCR) trzymamy w metadanych `attachments` (tags/custom fields/assignments), bez dodawania pÃ³l do `records_documents`.

- ~~Q4-INT-003 (P1)~~: Czy moduÅ‚ `records` potrzebuje integracji z moduÅ‚em `customers` (dla nadawcÃ³w/odbiorcÃ³w)? â€“ **ROZSTRZYGNIÄ˜TE**
  - **MVP: bez twardej zaleÅ¼noÅ›ci** â€“ `sender_name` pozostaje wymaganym free-text.
  - **Model hybrydowy (opcjonalny)**: `sender_id: uuid | null` (referencja do `customers`) + `sender_name: string` jako **snapshot/fallback**.
  - **AutouzupeÅ‚nianie**: UI moÅ¼e podpowiadaÄ‡ nadawcÃ³w z `customers`, ale zapis zawsze utrwala `sender_name` (odpornoÅ›Ä‡ na usuniÄ™cie/zmianÄ™ danych klienta).

### D) UI i UX

- ~~Q4-UI-001 (P0)~~: Jak wyglÄ…da formularz tworzenia/edycji dokumentu? â€“ **ROZSTRZYGNIÄ˜TE**
  - **Upload plikÃ³w**: inline w edycji dokumentu (drawer/slide-over) jako sekcja â€Plikiâ€. Dodatkowo szybka akcja â€Dodaj plikâ€ przy dokumencie na liÅ›cie.
  - **Dokument bez attachmentÃ³w**: dozwolony (metadata-only). Pliki mogÄ… byÄ‡ dodane pÃ³Åºniej.
  - **Lista attachmentÃ³w**: lista/tabela plikÃ³w (nazwa, typ/MIME, rozmiar, dodano, status, akcje: podglÄ…d/pobierz/usuÅ„). Thumbnails tylko jako opcjonalne ulepszenie (dla obrazÃ³w/PDF).
  - **Drag & drop**: wspierany w strefie upload w edycji dokumentu; w MVP dopuszczalne minimum to click-to-upload, a DnD jako enhancement.

- ~~Q4-UI-002 (P1)~~: Jak prezentujemy listÄ™ dokumentÃ³w na przesyÅ‚ce? â€“ **ROZSTRZYGNIÄ˜TE**
  - **Prezentacja**: inline tabela w formularzu przesyÅ‚ki (sekcja â€ZawartoÅ›Ä‡ przesyÅ‚kiâ€).
  - **Edycja bez opuszczania formularza**: edycja dokumentu w drawerze (preferowane) lub modalu.
  - **Dodawanie dokumentu**: przycisk â€Dodajâ€ z dropdownem:
    - â€Nowy dokument (metadane)â€,
    - â€Nowy dokument + dodaj plikâ€ (otwiera drawer i fokusuje upload).

- ~~Q4-UI-003 (P1)~~: Jak obsÅ‚ugujemy UI dla importu CSV JRWA? â€“ **ROZSTRZYGNIÄ˜TE**
  - **Forma**: osobna strona importu (nie modal).
  - **PodglÄ…d przed importem**: wymagany (walidacja + preview pierwszych N wierszy + podsumowanie ok/bÅ‚Ä™dy).
  - **Progress**: wymagany przy imporcie asynchronicznym (status joba + pasek postÄ™pu).
  - **Raport bÅ‚Ä™dÃ³w**: inline lista bÅ‚Ä™dÃ³w + moÅ¼liwoÅ›Ä‡ pobrania raportu (np. CSV/JSON) + filtr â€tylko bÅ‚Ä™dneâ€.

- ~~Q4-UI-004 (P2)~~: Jak pokazujemy historiÄ™ zmian przesyÅ‚ki (audit log)? â€“ **ROZSTRZYGNIÄ˜TE**
  - **Lokalizacja**: zakÅ‚adka â€Historiaâ€ na szczegÃ³Å‚ach przesyÅ‚ki albo sekcja/timeline na dole strony (spÃ³jnie ze â€SkÅ‚adem chronologicznymâ€).
  - **Format**: chronologiczna lista zdarzeÅ„ (kto/kiedy/co) + dla zmian pÃ³l widok â€przed â†’ poâ€ (zwijany).
  - **Zmiany dokumentÃ³w**: pokazywane jako zdarzenia (dodano/usuniÄ™to dokument, zmieniono metadane, dodano/usuniÄ™to plik).

#### Opis UX (MVP) â€“ spÃ³jny z ustaleniami

**Lista przesyÅ‚ek (RPW / w trakcie rejestracji)**
- Widok tabelaryczny (DataTable) z wyszukiwarkÄ… i filtrami (m.in. status `draft`/`registered`/`archived`, â€zarejestrowane przeze mnieâ€, â€metadane do uzupeÅ‚nieniaâ€).
- Kolumny MVP: RPW/tymczasowy numer, temat, nadawca, data wpÅ‚ywu, status, komÃ³rka organizacyjna (kancelaria), rejestrujÄ…cy.
- WejÅ›cie w szczegÃ³Å‚y przez klik w wiersz; akcje dodatkowe przez menu â€â€¦â€ (jeÅ›li potrzebne).

**SzczegÃ³Å‚y przesyÅ‚ki (create/edit)**
- UkÅ‚ad sekcyjny jak na referencyjnych ekranach: â€ZawartoÅ›Ä‡ przesyÅ‚kiâ€ (dokumenty), â€Dane przesyÅ‚kiâ€, â€Dane nadawcyâ€, â€SkÅ‚ad chronologicznyâ€, â€Potwierdzenieâ€.
- Przyciski: â€Zapiszâ€ i â€Anulujâ€ na dole; dodatkowo akcja procesowa â€Zarejestruj wpÅ‚ywâ€ dostÄ™pna tylko w `draft` i tylko dla uÅ¼ytkownikÃ³w z uprawnieniem `records.incoming_shipments.register`.
- SkrÃ³ty klawiaturowe: `Cmd/Ctrl+Enter` jako primary action (Zapisz / Zarejestruj â€“ zaleÅ¼nie od kontekstu), `Escape` jako anuluj/zamknij (zgodnie z konwencjÄ… UI repo).
- Walidacje: â€Zarejestruj wpÅ‚ywâ€ jest blokowane, jeÅ›li brakuje wymaganych pÃ³l z sekcji walidacji `register` (m.in. `subject`, `sender_name`, `delivery_method`, `received_at`, `receiving_org_unit_symbol`) albo jeÅ›li `document_ids` jest puste.
- Po rejestracji: przesyÅ‚ka pozostaje edytowalna zgodnie z Q3-VAL-002, ale `rpw_number` jest immutable.

**ZawartoÅ›Ä‡ przesyÅ‚ki (dokumenty)**
- Lista dokumentÃ³w jako tabela inline z akcjÄ… â€Dodajâ€.
- Przycisk â€Dodajâ€ dziaÅ‚a jako split-button:
  - Klik w gÅ‚Ã³wnÄ… czÄ™Å›Ä‡ wykonuje akcjÄ™ domyÅ›lnÄ….
  - Klik w chevron otwiera dropdown z wariantami.
  - Warianty w dropdown:
    - â€Nowy dokument + dodaj plikâ€ (tworzy dokument i od razu otwiera drawer z fokusem na upload).
    - â€Nowy dokument (metadane)â€ (tworzy dokument bez wymogu pliku i otwiera drawer na metadanych).
  - DomyÅ›lna akcja:
    - JeÅ›li przesyÅ‚ka nie ma jeszcze dokumentÃ³w: domyÅ›lnie â€Nowy dokument + dodaj plikâ€.
    - JeÅ›li uÅ¼ytkownik ostatnio wybraÅ‚ wariant (zapamiÄ™tanie preferencji per uÅ¼ytkownik w przeglÄ…darce) â€“ ten wariant staje siÄ™ domyÅ›lny.
    - JeÅ›li uÅ¼ytkownik Å›wiadomie prowadzi wpÅ‚yw â€bez zaÅ‚Ä…cznikÃ³wâ€ / dodaje metadane bez plikÃ³w: domyÅ›lnie â€Nowy dokument (metadane)â€.
- Kolumny i statusy w tabeli dokumentÃ³w (MVP):
  - Kolumny: LP, tytuÅ‚/nazwa dokumentu, rodzaj odwzorowania, status.
  - Status jako kompaktowe ikony + tooltip (mogÄ… wystÄ™powaÄ‡ 2â€“3 ikony naraz):
    - âœ… â€Metadane OKâ€ â€“ wymagane pola dokumentu sÄ… uzupeÅ‚nione.
    - âš ï¸ â€Wymaga uzupeÅ‚nieniaâ€ â€“ brakuje wymaganych metadanych dokumentu (np. `title`, `kind`, `access_level`).
    - â¬†ï¸ â€Wgrywanie/przetwarzanieâ€ â€“ trwa upload lub przetwarzanie plikÃ³w.
    - ğŸ“ â€Brak plikÃ³wâ€ â€“ dokument nie ma attachmentÃ³w (informacyjnie; nie blokuje rejestracji przesyÅ‚ki).
    - ğŸ”’/ğŸ‘¥/ğŸŒ â€DostÄ™pâ€ â€“ ikona poziomu dostÄ™pu dokumentu (`restricted`/`partial`/`public`).
- Edycja dokumentu w drawerze (prawy panel): metadane dokumentu + sekcja â€Plikiâ€ (upload + lista).
- Dokument moÅ¼e byÄ‡ utworzony bez plikÃ³w (metadata-only). Pliki moÅ¼na dodaÄ‡ pÃ³Åºniej.

**Upload i lista plikÃ³w (attachments)**
- Upload uruchamiany z drawer-a dokumentu: click-to-upload + opcjonalny drag&drop.
- W trakcie uploadu: stan â€wgrywanieâ€ + progres; po zakoÅ„czeniu: plik widoczny na liÅ›cie z akcjami (podglÄ…d/pobierz/usuÅ„).

**JRWA â€“ import CSV**
- Osobna strona importu z etapami: upload â†’ walidacja i podglÄ…d â†’ start importu.
- BÅ‚Ä™dy blokujÄ… import i sÄ… prezentowane w raporcie; przy imporcie asynchronicznym UI pokazuje postÄ™p i status joba.

**Historia (audit log) i skÅ‚ad chronologiczny**
- Historia jako timeline/zakÅ‚adka: zdarzenia dotyczÄ…ce przesyÅ‚ki, rejestracji (nadanie RPW), zmian dokumentÃ³w i zaÅ‚Ä…cznikÃ³w.
- SkÅ‚ad chronologiczny prezentowany jako osobna sekcja; zmiany przypisaÅ„/odnotowaÅ„ widoczne jako zdarzenia (MVP bez skomplikowanych diffÃ³w).

---

## 13A) Wzorce UI/UX - analiza istniejÄ…cych moduÅ‚Ã³w

:::info Å¹rÃ³dÅ‚o wzorcÃ³w
PoniÅ¼sza sekcja powstaÅ‚a na podstawie analizy istniejÄ…cych moduÅ‚Ã³w:
- **sales** (packages/core/src/modules/sales) - dokumenty sprzedaÅ¼y, faktury
- **catalog** (packages/core/src/modules/catalog) - produkty, kategorie
- **customers** (packages/core/src/modules/customers) - klienci, adresy

Wszystkie komponenty UI moduÅ‚u `records` muszÄ… byÄ‡ zgodne z tymi wzorcami dla zachowania spÃ³jnoÅ›ci interfejsu.
:::

### A1) Architektura komponentÃ³w UI

#### Struktura plikÃ³w (wzorzec z sales/catalog)
```
packages/core/src/modules/records/
â”œâ”€â”€ api/                          # Backend API (âœ… zaimplementowane)
â”œâ”€â”€ entities/                     # ORM entities (âœ… zaimplementowane)
â””â”€â”€ frontend/                     # Frontend UI (âŒ do zaimplementowania)
    â”œâ”€â”€ incoming-shipments/
    â”‚   â”œâ”€â”€ page.tsx              # Lista przesyÅ‚ek (DataTable)
    â”‚   â”œâ”€â”€ [id]/
    â”‚   â”‚   â””â”€â”€ page.tsx          # SzczegÃ³Å‚y/edycja przesyÅ‚ki
    â”‚   â”œâ”€â”€ new/
    â”‚   â”‚   â””â”€â”€ page.tsx          # Nowa przesyÅ‚ka
    â”‚   â”œâ”€â”€ IncomingShipmentForm.tsx     # GÅ‚Ã³wny formularz
    â”‚   â”œâ”€â”€ ShipmentDocumentsSection.tsx # Sekcja dokumentÃ³w (embedded)
    â”‚   â””â”€â”€ ShipmentDocumentDialog.tsx   # Dialog dodawania dokumentu
    â”œâ”€â”€ jrwa-classes/
    â”‚   â”œâ”€â”€ page.tsx              # Lista/drzewo klas JRWA
    â”‚   â”œâ”€â”€ [id]/
    â”‚   â”‚   â””â”€â”€ page.tsx          # Edycja klasy
    â”‚   â”œâ”€â”€ new/
    â”‚   â”‚   â””â”€â”€ page.tsx          # Nowa klasa
    â”‚   â”œâ”€â”€ import/
    â”‚   â”‚   â””â”€â”€ page.tsx          # Import CSV
    â”‚   â””â”€â”€ JrwaClassForm.tsx     # Formularz klasy
    â””â”€â”€ backend/                  # Backend-only pages (admin)
        â”œâ”€â”€ incoming-shipments/
        â”‚   â””â”€â”€ page.tsx          # Lista dla admina
        â””â”€â”€ jrwa-classes/
            â””â”€â”€ page.tsx          # Admin JRWA
```

#### Konwencje nazewnicze
- **Pages**: `page.tsx` (Next.js App Router convention)
- **Forms**: `<EntityName>Form.tsx` (np. `IncomingShipmentForm.tsx`)
- **Sections**: `<Purpose>Section.tsx` (np. `ShipmentDocumentsSection.tsx`)
- **Dialogs**: `<Entity>Dialog.tsx` (np. `ShipmentDocumentDialog.tsx`)
- **Tables**: `<Entity>DataTable.tsx` lub `<Entity>Table.tsx`

### A2) Komponenty bazowe (do wykorzystania)

#### CrudForm (wzorzec: SalesDocumentForm.tsx)
```typescript
import { CrudForm } from '@open-mercato/ui/backend/CrudForm';
import type { CrudField, CrudFormGroup } from '@open-mercato/ui/backend/CrudForm/types';

// Definicja pÃ³l formularza
const incomingShipmentFields: CrudField[] = [
  {
    name: 'subject',
    label: 'Temat przesyÅ‚ki',
    type: 'text',
    required: true,
    placeholder: 'Wpisz temat...',
  },
  {
    name: 'senderDisplayName',
    label: 'Nadawca',
    type: 'text',
    required: true,
  },
  {
    name: 'deliveryMethod',
    label: 'SposÃ³b wpÅ‚ywu',
    type: 'select',
    required: true,
    options: [
      { value: 'paper', label: 'Papier' },
      { value: 'epuap', label: 'ePUAP' },
      { value: 'email', label: 'E-mail' },
      { value: 'other', label: 'Inny' },
    ],
  },
  {
    name: 'receivedAt',
    label: 'Data wpÅ‚ywu',
    type: 'date',
    required: true,
  },
  {
    name: 'receivingOrgUnitId',
    label: 'Kancelaria (komÃ³rka organizacyjna)',
    type: 'lookup',
    required: true,
    lookupConfig: {
      module: 'organizational',
      entityId: 'orgUnits',
      displayField: 'name',
      searchFields: ['name', 'symbol'],
    },
  },
  {
    name: 'status',
    label: 'Status',
    type: 'select',
    required: true,
    disabled: true, // tylko do odczytu; zmienia siÄ™ przez akcje
    options: [
      { value: 'draft', label: 'Robocza' },
      { value: 'registered', label: 'Zarejestrowana' },
      // PrzyszÅ‚e statusy (do zaimplementowania):
      // { value: 'archived', label: 'Zarchiwizowana' },
      // { value: 'deleted', label: 'Zbrakowana' },
      // { value: 'return', label: 'ZwrÃ³cona' },
    ],
  },
];

// Grupowanie pÃ³l w sekcje
const incomingShipmentFormGroups: CrudFormGroup[] = [
  {
    title: 'Dane przesyÅ‚ki',
    fields: ['subject', 'deliveryMethod', 'receivedAt', 'status'],
  },
  {
    title: 'Dane nadawcy',
    fields: ['senderDisplayName'],
  },
  {
    title: 'Dane rejestracji',
    fields: ['receivingOrgUnitId', 'rpwNumber'], // rpwNumber readonly
  },
];

// UÅ¼ycie w komponencie
export function IncomingShipmentForm({ initialData, mode }: Props) {
  return (
    <CrudForm
      fields={incomingShipmentFields}
      groups={incomingShipmentFormGroups}
      initialData={initialData}
      mode={mode} // 'create' | 'edit'
      onSubmit={handleSubmit}
      customFieldRender={(field, props) => {
        // Custom rendering dla specjalnych pÃ³l
        if (field.name === 'rpwNumber' && mode === 'edit') {
          return <div className="text-sm text-muted">{initialData.rpwNumber || 'â€”'}</div>;
        }
        return null; // uÅ¼yj domyÅ›lnego renderingu
      }}
    />
  );
}
```

**Kluczowe cechy CrudForm**:
- Automatyczna walidacja (Zod schema)
- ObsÅ‚uga custom fields (lookup, dictionary, multi-select)
- Grupowanie pÃ³l w sekcje (accordion lub tabs)
- ObsÅ‚uga disabled/readonly fields
- Custom field rendering przez `customFieldRender`

#### DataTable (wzorzec: SalesDocumentsTable.tsx, ProductsDataTable.tsx)
```typescript
import { DataTable } from '@open-mercato/ui/backend/DataTable';
import { ColumnDef } from '@tanstack/react-table';
import { RowActions } from '@open-mercato/ui/backend/RowActions';

// Definicja kolumn
const incomingShipmentsColumns: ColumnDef<IncomingShipmentRow>[] = [
  {
    accessorKey: 'rpwNumber',
    header: 'Numer RPW',
    cell: ({ row }) => (
      <Link href={`/records/incoming-shipments/${row.original.id}`}>
        {row.original.rpwNumber || <span className="text-muted">â€”</span>}
      </Link>
    ),
  },
  {
    accessorKey: 'subject',
    header: 'Temat',
    cell: ({ row }) => (
      <div className="max-w-[300px] truncate">{row.original.subject}</div>
    ),
  },
  {
    accessorKey: 'senderDisplayName',
    header: 'Nadawca',
  },
  {
    accessorKey: 'receivedAt',
    header: 'Data wpÅ‚ywu',
    cell: ({ row }) => {
      const date = row.original.receivedAt;
      return date ? new Date(date).toLocaleDateString('pl-PL') : 'â€”';
    },
  },
  {
    accessorKey: 'status',
    header: 'Status',
    cell: ({ row }) => {
      const statusLabels = {
        draft: 'Roboczy',
        registered: 'Zarejestrowany',
        // PrzyszÅ‚e:
        // archived: 'Zarchiwizowany',
      };
      return statusLabels[row.original.status] || row.original.status;
    },
  },
  {
    id: 'actions',
    cell: ({ row }) => (
      <RowActions
        row={row}
        editHref={`/records/incoming-shipments/${row.original.id}`}
        onDelete={() => handleDelete(row.original.id)}
        deletePermission="records.incoming_shipments.manage"
      />
    ),
  },
];

// UÅ¼ycie w page.tsx
export default function IncomingShipmentsPage() {
  return (
    <DataTable
      columns={incomingShipmentsColumns}
      endpoint="/api/records/incoming-shipments"
      searchPlaceholder="Szukaj po temacie, nadawcy, numerze RPW..."
      filters={[
        { key: 'status', label: 'Status', type: 'select', options: [...] },
        { key: 'receivedAtFrom', label: 'Data wpÅ‚ywu od', type: 'date' },
        { key: 'receivedAtTo', label: 'Data wpÅ‚ywu do', type: 'date' },
      ]}
      createButton={{
        label: 'Nowa przesyÅ‚ka',
        href: '/records/incoming-shipments/new',
        permission: 'records.incoming_shipments.manage',
      }}
    />
  );
}
```

**Kluczowe cechy DataTable**:
- Automatyczna paginacja, sortowanie, filtrowanie
- Server-side data fetching (endpoint jako prop)
- RowActions component dla edit/delete
- Feature gates (permissions) dla akcji
- Export do CSV/Excel (opcjonalnie)
- Custom column rendering

#### Embedded Sections (wzorzec: ItemsSection.tsx, AdjustmentsSection.tsx)
```typescript
'use client';

import { useState } from 'react';
import { Button } from '@open-mercato/ui/primitives/Button';
import { DataTable } from '@open-mercato/ui/backend/DataTable';
import { ShipmentDocumentDialog } from './ShipmentDocumentDialog';

interface ShipmentDocumentsSectionProps {
  shipmentId: string;
  documents: DocumentRow[];
  readonly?: boolean;
  onDocumentsChange?: (documents: DocumentRow[]) => void;
}

export function ShipmentDocumentsSection({
  shipmentId,
  documents,
  readonly,
  onDocumentsChange,
}: ShipmentDocumentsSectionProps) {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [editingDocument, setEditingDocument] = useState<DocumentRow | null>(null);

  const handleAddDocument = () => {
    setEditingDocument(null);
    setIsDialogOpen(true);
  };

  const handleEditDocument = (doc: DocumentRow) => {
    setEditingDocument(doc);
    setIsDialogOpen(true);
  };

  const handleDocumentSaved = async (payload: DocumentPayload) => {
    // API call do zapisu dokumentu
    const result = await apiCall(
      editingDocument
        ? `/api/records/documents?id=${editingDocument.id}`
        : '/api/records/documents',
      {
        method: editingDocument ? 'PUT' : 'POST',
        body: JSON.stringify({ ...payload, shipmentId }),
      }
    );

    if (result.success) {
      // OdÅ›wieÅ¼ listÄ™ dokumentÃ³w
      const updatedDocs = editingDocument
        ? documents.map((d) => (d.id === editingDocument.id ? result.data : d))
        : [...documents, result.data];
      
      onDocumentsChange?.(updatedDocs);
      setIsDialogOpen(false);
      flash({ type: 'success', message: 'Dokument zapisany' });
    }
  };

  const columns: ColumnDef<DocumentRow>[] = [
    {
      accessorKey: 'title',
      header: 'TytuÅ‚ dokumentu',
      cell: ({ row }) => (
        <button
          onClick={() => handleEditDocument(row.original)}
          className="text-left hover:underline"
        >
          {row.original.title}
        </button>
      ),
    },
    {
      accessorKey: 'attachmentCount',
      header: 'ZaÅ‚Ä…czniki',
      cell: ({ row }) => `${row.original.attachmentCount || 0} plik(Ã³w)`,
    },
    {
      id: 'actions',
      cell: ({ row }) => (
        <RowActions
          row={row}
          onEdit={() => handleEditDocument(row.original)}
          onDelete={() => handleDeleteDocument(row.original.id)}
          deletePermission="records.documents.manage"
        />
      ),
    },
  ];

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">ZawartoÅ›Ä‡ przesyÅ‚ki</h3>
        {!readonly && (
          <Button onClick={handleAddDocument} size="sm">
            Dodaj dokument
          </Button>
        )}
      </div>

      <DataTable
        data={documents}
        columns={columns}
        emptyMessage="Brak dokumentÃ³w. Dodaj pierwszy dokument."
      />

      <ShipmentDocumentDialog
        open={isDialogOpen}
        onOpenChange={setIsDialogOpen}
        initialData={editingDocument}
        onSave={handleDocumentSaved}
      />
    </div>
  );
}
```

**Kluczowe cechy Embedded Sections**:
- Client component ("use client")
- Props: parentId, data, callbacks (onDataChange)
- Embedded dialog dla CRUD sub-items
- Synchronizacja z parent form przez callbacks
- Walidacja i permissions

#### Dialogs (wzorzec: LineItemDialog.tsx)
```typescript
'use client';

import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@open-mercato/ui/primitives/Dialog';
import { Button } from '@open-mercato/ui/primitives/Button';
import { Input } from '@open-mercato/ui/primitives/Input';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const documentSchema = z.object({
  title: z.string().min(1, 'TytuÅ‚ jest wymagany'),
  description: z.string().optional(),
  documentType: z.string().min(1, 'Typ dokumentu jest wymagany'),
});

type DocumentFormData = z.infer<typeof documentSchema>;

interface ShipmentDocumentDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  initialData?: DocumentRow | null;
  onSave: (data: DocumentFormData) => Promise<void>;
}

export function ShipmentDocumentDialog({
  open,
  onOpenChange,
  initialData,
  onSave,
}: ShipmentDocumentDialogProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
  } = useForm<DocumentFormData>({
    resolver: zodResolver(documentSchema),
    defaultValues: initialData || {},
  });

  const onSubmit = async (data: DocumentFormData) => {
    await onSave(data);
    reset();
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>
            {initialData ? 'Edytuj dokument' : 'Nowy dokument'}
          </DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <label htmlFor="title" className="block text-sm font-medium">
              TytuÅ‚ dokumentu *
            </label>
            <Input
              id="title"
              {...register('title')}
              error={errors.title?.message}
            />
          </div>

          <div>
            <label htmlFor="description" className="block text-sm font-medium">
              Opis
            </label>
            <Input
              id="description"
              {...register('description')}
              error={errors.description?.message}
            />
          </div>

          <div>
            <label htmlFor="documentType" className="block text-sm font-medium">
              Typ dokumentu *
            </label>
            <select
              id="documentType"
              {...register('documentType')}
              className="w-full rounded-md border p-2"
            >
              <option value="">Wybierz...</option>
              <option value="official">Pismo urzÄ™dowe</option>
              <option value="invoice">Faktura</option>
              <option value="contract">Umowa</option>
              <option value="other">Inny</option>
            </select>
            {errors.documentType && (
              <p className="text-sm text-red-500">{errors.documentType.message}</p>
            )}
          </div>

          <div className="flex justify-end gap-2">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
            >
              Anuluj
            </Button>
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Zapisywanie...' : 'Zapisz'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
```

**Kluczowe cechy Dialogs**:
- React Hook Form + Zod validation
- Props: open, onOpenChange, initialData, onSave
- Submit handler zwraca Promise (async save)
- Reset form po zapisie
- Loading state podczas submitu

### A3) SzczegÃ³lne przypadki UI

#### Akcja "Zarejestruj wpÅ‚yw" (custom action button)
```typescript
'use client';

import { Button } from '@open-mercato/ui/primitives/Button';
import { usePermissions } from '@open-mercato/auth/hooks';
import { apiCall } from '@open-mercato/api';
import { flash } from '@open-mercato/ui/flash';

interface RegisterShipmentButtonProps {
  shipmentId: string;
  status: string;
  canRegister: boolean; // na podstawie walidacji
  onRegistered: () => void;
}

export function RegisterShipmentButton({
  shipmentId,
  status,
  canRegister,
  onRegistered,
}: RegisterShipmentButtonProps) {
  const { hasPermission } = usePermissions();
  const canUserRegister = hasPermission('records.incoming_shipments.register');

  const handleRegister = async () => {
    const result = await apiCall(
      `/api/records/incoming-shipments/${shipmentId}/register`,
      { method: 'POST' }
    );

    if (result.success) {
      flash({ type: 'success', message: `PrzesyÅ‚ka zarejestrowana. RPW: ${result.data.rpwNumber}` });
      onRegistered();
    } else {
      flash({ type: 'error', message: result.error || 'BÅ‚Ä…d rejestracji' });
    }
  };

  if (status !== 'draft' || !canUserRegister) {
    return null; // nie pokazuj przycisku
  }

  return (
    <Button
      onClick={handleRegister}
      disabled={!canRegister}
      variant="primary"
      title={!canRegister ? 'UzupeÅ‚nij wymagane pola i dodaj dokumenty' : ''}
    >
      Zarejestruj wpÅ‚yw (Ctrl+Enter)
    </Button>
  );
}
```

#### JRWA - hierarchiczne drzewo (tree view)
```typescript
'use client';

import { useState } from 'react';
import { ChevronRight, ChevronDown } from 'lucide-react';

interface JrwaTreeNodeProps {
  node: JrwaClassRow;
  children?: JrwaClassRow[];
  level: number;
  onSelect: (node: JrwaClassRow) => void;
}

export function JrwaTreeNode({ node, children, level, onSelect }: JrwaTreeNodeProps) {
  const [isExpanded, setIsExpanded] = useState(level === 0);
  const hasChildren = children && children.length > 0;

  return (
    <div>
      <div
        className="flex items-center gap-2 py-2 px-4 hover:bg-gray-100 cursor-pointer"
        style={{ paddingLeft: `${level * 24 + 16}px` }}
        onClick={() => onSelect(node)}
      >
        {hasChildren && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              setIsExpanded(!isExpanded);
            }}
            className="p-1"
          >
            {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
          </button>
        )}
        {!hasChildren && <div className="w-6" />}
        
        <span className="font-mono text-sm">{node.code}</span>
        <span className="text-sm">{node.name}</span>
        <span className="text-xs text-muted ml-auto">{node.retentionCategory}</span>
      </div>

      {isExpanded && hasChildren && (
        <div>
          {children.map((child) => (
            <JrwaTreeNode
              key={child.id}
              node={child}
              children={child.children}
              level={level + 1}
              onSelect={onSelect}
            />
          ))}
        </div>
      )}
    </div>
  );
}

// UÅ¼ycie w page
export function JrwaClassesTreeView({ classes }: { classes: JrwaClassRow[] }) {
  const handleSelect = (node: JrwaClassRow) => {
    // OtwÃ³rz drawer/dialog z detalami lub przekieruj do edycji
    router.push(`/records/jrwa-classes/${node.id}`);
  };

  return (
    <div className="border rounded-lg">
      {classes.map((rootClass) => (
        <JrwaTreeNode
          key={rootClass.id}
          node={rootClass}
          children={rootClass.children}
          level={0}
          onSelect={handleSelect}
        />
      ))}
    </div>
  );
}
```

#### Import CSV - multi-step wizard
```typescript
'use client';

import { useState } from 'react';
import { Button } from '@open-mercato/ui/primitives/Button';
import { UploadDropzone } from '@open-mercato/ui/components/UploadDropzone';
import { apiCall } from '@open-mercato/api';

enum ImportStep {
  Upload = 'upload',
  Validate = 'validate',
  Preview = 'preview',
  Import = 'import',
  Result = 'result',
}

export default function JrwaImportPage() {
  const [step, setStep] = useState<ImportStep>(ImportStep.Upload);
  const [file, setFile] = useState<File | null>(null);
  const [validationResult, setValidationResult] = useState<any>(null);
  const [importResult, setImportResult] = useState<any>(null);

  const handleFileSelected = async (selectedFile: File) => {
    setFile(selectedFile);
    setStep(ImportStep.Validate);

    // Walidacja pliku
    const formData = new FormData();
    formData.append('file', selectedFile);
    
    const result = await apiCall('/api/records/jrwa-classes/validate-csv', {
      method: 'POST',
      body: formData,
    });

    setValidationResult(result);
    setStep(ImportStep.Preview);
  };

  const handleImport = async () => {
    setStep(ImportStep.Import);

    const formData = new FormData();
    formData.append('file', file!);

    const result = await apiCall('/api/records/jrwa-classes/import', {
      method: 'POST',
      body: formData,
    });

    setImportResult(result);
    setStep(ImportStep.Result);
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-2xl font-bold mb-6">Import klas JRWA z CSV</h1>

      {step === ImportStep.Upload && (
        <UploadDropzone
          accept=".csv"
          onFileSelected={handleFileSelected}
          description="PrzeciÄ…gnij plik CSV lub kliknij aby wybraÄ‡"
        />
      )}

      {step === ImportStep.Validate && (
        <div className="text-center py-12">
          <p>Walidacja pliku...</p>
        </div>
      )}

      {step === ImportStep.Preview && validationResult && (
        <div className="space-y-4">
          <div className="bg-blue-50 p-4 rounded">
            <p>Znaleziono: {validationResult.totalRows} wierszy</p>
            <p>Poprawnych: {validationResult.validRows}</p>
            <p>BÅ‚Ä™dnych: {validationResult.errorRows}</p>
          </div>

          {validationResult.errors.length > 0 && (
            <div className="bg-red-50 p-4 rounded">
              <h3 className="font-semibold mb-2">BÅ‚Ä™dy:</h3>
              <ul className="list-disc list-inside">
                {validationResult.errors.map((err: any, idx: number) => (
                  <li key={idx}>
                    Wiersz {err.row}: {err.message}
                  </li>
                ))}
              </ul>
            </div>
          )}

          <div className="flex justify-end gap-2">
            <Button variant="outline" onClick={() => setStep(ImportStep.Upload)}>
              Anuluj
            </Button>
            <Button
              onClick={handleImport}
              disabled={validationResult.errorRows > 0}
            >
              Importuj ({validationResult.validRows} klas)
            </Button>
          </div>
        </div>
      )}

      {step === ImportStep.Import && (
        <div className="text-center py-12">
          <p>Importowanie...</p>
          <div className="w-full bg-gray-200 rounded-full h-2 mt-4">
            <div className="bg-blue-600 h-2 rounded-full animate-pulse" style={{ width: '60%' }} />
          </div>
        </div>
      )}

      {step === ImportStep.Result && importResult && (
        <div className="space-y-4">
          {importResult.success ? (
            <div className="bg-green-50 p-4 rounded">
              <p className="font-semibold">Import zakoÅ„czony pomyÅ›lnie!</p>
              <p>Zaimportowano: {importResult.imported} klas</p>
            </div>
          ) : (
            <div className="bg-red-50 p-4 rounded">
              <p className="font-semibold">Import nieudany</p>
              <p>{importResult.error}</p>
            </div>
          )}

          <Button onClick={() => router.push('/records/jrwa-classes')}>
            WrÃ³Ä‡ do listy
          </Button>
        </div>
      )}
    </div>
  );
}
```

### A4) Wykorzystanie istniejÄ…cych komponentÃ³w (reuse)

:::info ReuÅ¼ywalne komponenty z issues/390
Zgodnie z ustaleniami w issues/390, naleÅ¼y wykorzystaÄ‡ istniejÄ…ce komponenty:
- **NotesSection** - do notatek/uwag na przesyÅ‚ce
- **AddressSection** - do danych adresowych nadawcy (jeÅ›li rozszerzymy model)
- **AttachmentsSection** - do zaÅ‚Ä…cznikÃ³w dokumentÃ³w (upload + lista plikÃ³w)

Te komponenty sÄ… uÅ¼ywane w module `customers` i zapewniajÄ… spÃ³jny UX.
:::

```typescript
// PrzykÅ‚ad uÅ¼ycia NotesSection
import { NotesSection } from '@open-mercato/ui/components/NotesSection';

export function IncomingShipmentDetailPage({ shipment }: Props) {
  return (
    <div className="space-y-6">
      {/* ... inne sekcje ... */}
      
      <NotesSection
        entityType="incoming_shipment"
        entityId={shipment.id}
        organizationId={shipment.organizationId}
        tenantId={shipment.tenantId}
      />
    </div>
  );
}
```

### A5) Kluczowe hooki i utilities

```typescript
// Multi-tenant context
import { useOrganizationScopeDetail } from '@open-mercato/auth/hooks';

const { organizationId, tenantId } = useOrganizationScopeDetail();

// Permissions
import { usePermissions } from '@open-mercato/auth/hooks';

const { hasPermission, hasAnyPermission } = usePermissions();
const canRegister = hasPermission('records.incoming_shipments.register');

// API calls
import { apiCall } from '@open-mercato/api';

const result = await apiCall('/api/records/incoming-shipments', {
  method: 'POST',
  body: JSON.stringify(payload),
});

// Flash notifications
import { flash } from '@open-mercato/ui/flash';

flash({ type: 'success', message: 'PrzesyÅ‚ka zapisana' });
flash({ type: 'error', message: 'BÅ‚Ä…d walidacji' });

// Router (Next.js App Router)
import { useRouter } from 'next/navigation';

const router = useRouter();
router.push('/records/incoming-shipments');
router.refresh(); // force re-fetch server data
```

### A6) Podsumowanie wzorcÃ³w

| Komponent | UÅ¼ycie | Wzorzec z |
|-----------|--------|-----------|
| **CrudForm** | Formularze create/edit | SalesDocumentForm.tsx |
| **DataTable** | Listy z filtrowaniem | ProductsDataTable.tsx |
| **RowActions** | Akcje edit/delete w tabeli | Wszystkie DataTable |
| **Embedded Section** | Sub-entities (dokumenty na przesyÅ‚ce) | ItemsSection.tsx |
| **Dialog** | Modals dla CRUD | LineItemDialog.tsx |
| **TreeView** | Hierarchiczne dane (JRWA) | (custom, ale wzorowany na category tree) |
| **Multi-step wizard** | Import CSV | (custom, ale pattern z upload flows) |
| **NotesSection** | Notatki/uwagi | customers module |
| **AttachmentsSection** | Upload plikÃ³w | customers module |

**Wszystkie komponenty muszÄ…**:
- ObsÅ‚ugiwaÄ‡ permissions (feature gates)
- ByÄ‡ tenant-scoped (organizationId + tenantId)
- UÅ¼ywaÄ‡ flash notifications dla feedbacku
- MieÄ‡ loading states
- ObsÅ‚ugiwaÄ‡ bÅ‚Ä™dy (error boundaries lub try-catch)
- ByÄ‡ responsywne (mobile-friendly)

---

### E) Performance i indeksy
- **Q4-PERF-001 (P1)**: Czy potrzebujemy indeksu na `sender_name` dla filtrowania?
  - filtr `sender_name contains` bez indeksu moÅ¼e byÄ‡ wolny przy duÅ¼ej liczbie przesyÅ‚ek
  - czy dodajemy trigram index (GIN/GiST) dla like/ilike queries?
  - czy wystarczy indeks partial (tylko dla najczÄ™Å›ciej wyszukiwanych)?

- **Q4-PERF-002 (P1)**: Czy lista dokumentÃ³w wymaga optymalizacji?
  - N+1 query problem przy pobieraniu dokumentÃ³w dla wielu przesyÅ‚ek?
  - czy potrzebujemy eager loading/join dla `document_ids`?
  - czy QueryEngine wspiera efektywne rozwijanie relacji arrayâ†’UUID?

- **Q4-PERF-003 (P2)**: Jak optymalizujemy drzewo JRWA?
  - czy budujemy materialized path dla szybkiego traversal?
  - czy cachujemy peÅ‚ne drzewo w pamiÄ™ci (Redis)?
  - jak czÄ™sto drzewo JRWA siÄ™ zmienia (cache invalidation strategy)?

---

## 13B) Integracje z innymi moduÅ‚ami

:::info Kontekst
ModuÅ‚ `records` nie jest izolowany - wspÃ³Å‚pracuje z innymi moduÅ‚ami repozytorium. PoniÅ¼ej zestawienie integracji wymaganych dla peÅ‚nej funkcjonalnoÅ›ci.
:::

### B1) Integracja z moduÅ‚em `organizational` (struktura organizacyjna)

**Wymagane pola z org structure**:
- **`receiving_org_unit_id`**: UUID komÃ³rki organizacyjnej (kancelarii) do ktÃ³rej wpÅ‚ywa przesyÅ‚ka
- **`receiving_org_unit_symbol`**: Symbol komÃ³rki (uÅ¼ywany jako `kanc_id` w numerze RPW)

**Implementacja**:
```typescript
// W formularzu przesyÅ‚ki - pole lookup do organizational units
{
  name: 'receivingOrgUnitId',
  type: 'lookup',
  lookupConfig: {
    module: 'organizational',
    entityId: 'orgUnits',
    endpoint: '/api/organizational/org-units',
    displayField: 'name',
    searchFields: ['name', 'symbol'],
    valueField: 'id',
    additionalFields: ['symbol'], // potrzebujemy symbol dla RPW
  },
  onChange: (value, additionalData) => {
    // Automatycznie wypeÅ‚nij receiving_org_unit_symbol
    form.setValue('receivingOrgUnitSymbol', additionalData.symbol);
  },
}
```

**API contract**:
- **GET** `/api/organizational/org-units?tenantId=X&organizationId=Y`
- Response: `{ id, name, symbol, parentId, level, ... }`

**Decyzje (z Q3-INT-001)**:
- âœ… Snapshot `receiving_org_unit_symbol` na przesyÅ‚ce (nie lookup w runtime)
- âœ… Walidacja: `receiving_org_unit_symbol` musi byÄ‡ wypeÅ‚niony przed rejestracjÄ…
- âŒ Brak foreign key constraint (zgodnie z zasadÄ… izomorficznych moduÅ‚Ã³w)

### B2) Integracja z moduÅ‚em `attachments` (pliki/zaÅ‚Ä…czniki)

**Use case**: Dokumenty na przesyÅ‚ce mogÄ… mieÄ‡ zaÅ‚Ä…czniki (pliki PDF, obrazy skanÃ³w, itp.)

**Model danych**:
```typescript
// RecordsDocument ma pole:
attachmentIds: string[]; // UUID[] do attachments.files

// Lub wykorzystujemy AttachmentsSection z customers module
```

**Implementacja**:
```typescript
// W ShipmentDocumentDialog - sekcja upload
import { AttachmentsSection } from '@open-mercato/ui/components/AttachmentsSection';

<AttachmentsSection
  entityType="records_document"
  entityId={document.id}
  organizationId={organizationId}
  tenantId={tenantId}
  readonly={readonly}
  onAttachmentsChange={(attachments) => {
    // Aktualizuj document.attachmentIds
    updateDocument({ attachmentIds: attachments.map(a => a.id) });
  }}
/>
```

**API contract**:
- **POST** `/api/attachments/upload` - upload pliku
- **GET** `/api/attachments/files?entityType=records_document&entityId=X`
- **DELETE** `/api/attachments/files?id=X`

**Decyzje (z Q3-INT-002)**:
- âœ… UÅ¼ywamy istniejÄ…cego moduÅ‚u `attachments` (nie tworzymy wÅ‚asnego storage)
- âœ… Attachments powiÄ…zane z `RecordsDocument` (nie bezpoÅ›rednio z przesyÅ‚kÄ…)
- âœ… Soft delete attachments (deletedAt) przy usuniÄ™ciu dokumentu

### B3) Integracja z moduÅ‚em `directory` (rejestr kontrahentÃ³w)

**Use case**: Nadawca przesyÅ‚ki moÅ¼e byÄ‡ podmiotem z rejestru kontrahentÃ³w

**Model danych**:
```typescript
// RecordsIncomingShipment ma pola:
senderId?: string; // UUID do directory.subjects (opcjonalne)
senderDisplayName: string; // nazwa nadawcy (snapshot lub custom)
senderAddress?: string; // adres nadawcy (snapshot)
```

**Implementacja**:
```typescript
// W formularzu - pole lookup z opcjÄ… custom input
{
  name: 'senderId',
  type: 'lookup-or-custom',
  lookupConfig: {
    module: 'directory',
    entityId: 'subjects',
    endpoint: '/api/directory/subjects',
    displayField: 'name',
    searchFields: ['name', 'taxId', 'regon'],
    valueField: 'id',
  },
  customFieldName: 'senderDisplayName',
  customFieldLabel: 'Lub wpisz nazwÄ™ nadawcy',
  onChange: (value, subject) => {
    if (subject) {
      // Automatycznie wypeÅ‚nij dane ze sÅ‚ownika
      form.setValue('senderDisplayName', subject.name);
      form.setValue('senderAddress', subject.address);
    }
  },
}
```

**API contract**:
- **GET** `/api/directory/subjects?search=X&tenantId=Y`
- Response: `{ id, name, taxId, regon, address, ... }`

**Decyzje (z Q2-SHIP-002)**:
- âœ… `senderId` jest opcjonalne (moÅ¼liwoÅ›Ä‡ wpisania custom nadawcy)
- âœ… Snapshot `senderDisplayName` i `senderAddress` (nie lookup w runtime)
- âœ… Walidacja: albo `senderId` albo `senderDisplayName` musi byÄ‡ wypeÅ‚nione (XOR)

### B4) Integracja z moduÅ‚em `auth` (uÅ¼ytkownicy i uprawnienia)

**Use case**: Logowanie uÅ¼ytkownika rejestrujÄ…cego przesyÅ‚kÄ™, kontrola uprawnieÅ„

**Model danych**:
```typescript
// RecordsIncomingShipment ma pola:
createdBy: string; // UUID uÅ¼ytkownika tworzÄ…cego
registeredBy?: string; // UUID uÅ¼ytkownika rejestrujÄ…cego wpÅ‚yw
```

**Implementacja**:
```typescript
// Automatyczne wypeÅ‚nienie w API
import { getAuthUser } from '@open-mercato/auth/server';

const user = await getAuthUser();

// W POST /api/records/incoming-shipments
const shipment = await repo.create({
  ...payload,
  createdBy: user.id,
  tenantId: user.tenantId,
  organizationId: user.organizationId,
});

// W POST /api/records/incoming-shipments/:id/register
await repo.update(id, {
  status: 'registered',
  rpwNumber: generatedRpw,
  registeredBy: user.id,
  registeredAt: new Date(),
});
```

**Permissions (feature gates)**:
- Sprawdzanie: `usePermissions()` hook na frontendzie
- Enforcement: middleware na API routes

```typescript
// W API route
import { requirePermission } from '@open-mercato/auth/middleware';

export const POST = requirePermission('records.incoming_shipments.register')(
  async (req: Request) => {
    // ... logika rejestracji
  }
);
```

### B5) Integracja z moduÅ‚em `audit` (historia zmian)

**Use case**: Logowanie wszystkich zmian w przesyÅ‚ce (audit trail)

**Implementacja**:
```typescript
import { auditLog } from '@open-mercato/audit';

// Po kaÅ¼dej zmianie przesyÅ‚ki
await auditLog({
  entityType: 'records_incoming_shipment',
  entityId: shipment.id,
  action: 'update',
  changes: {
    subject: { before: oldSubject, after: newSubject },
    status: { before: 'draft', after: 'registered' },
  },
  userId: user.id,
  tenantId: shipment.tenantId,
  organizationId: shipment.organizationId,
});

// Po rejestracji wpÅ‚ywu
await auditLog({
  entityType: 'records_incoming_shipment',
  entityId: shipment.id,
  action: 'register',
  metadata: {
    rpwNumber: shipment.rpwNumber,
    registeredBy: user.id,
    registeredAt: new Date().toISOString(),
  },
  userId: user.id,
  tenantId: shipment.tenantId,
  organizationId: shipment.organizationId,
});
```

**Prezentacja w UI**:
```typescript
// W szczegÃ³Å‚ach przesyÅ‚ki - zakÅ‚adka Historia
import { AuditTimeline } from '@open-mercato/ui/components/AuditTimeline';

<AuditTimeline
  entityType="records_incoming_shipment"
  entityId={shipment.id}
  organizationId={organizationId}
  tenantId={tenantId}
/>
```

### B6) Integracja z moduÅ‚em `search` (globalne wyszukiwanie Cmd+K)

**Wymagane**:
- âœ… `formatResult()` w `records/search.ts`
- âœ… `entityId` registered w generatorze moduÅ‚Ã³w
- âœ… Tokenizacja pÃ³l do indeksowania

**Implementacja** (juÅ¼ zaimplementowane):
```typescript
// packages/core/src/modules/records/search.ts
export const recordsSearchConfig = {
  entities: [
    {
      entityId: 'records.incoming_shipments',
      formatResult: (row: IncomingShipmentRow) => ({
        title: row.subject,
        subtitle: row.rpwNumber || 'Roboczy',
        description: `Nadawca: ${row.senderDisplayName} Â· ${formatDate(row.receivedAt)}`,
        href: `/records/incoming-shipments/${row.id}`,
        icon: 'inbox',
      }),
      searchFields: ['subject', 'senderDisplayName', 'rpwNumber'],
    },
    {
      entityId: 'records.jrwa_classes',
      formatResult: (row: JrwaClassRow) => ({
        title: `${row.code} â€” ${row.name}`,
        subtitle: `Retencja: ${row.retentionCategory}`,
        description: row.description || '',
        href: `/records/jrwa-classes/${row.id}`,
        icon: 'folder-tree',
      }),
      searchFields: ['code', 'name', 'description'],
    },
  ],
};
```

### B7) Podsumowanie integracji

| ModuÅ‚ docelowy | Typ integracji | Status | Priorytet |
|----------------|----------------|--------|-----------|
| **organizational** | Lookup org units (kancelarie) | âœ… Design ready | P0 (MVP) |
| **attachments** | Upload/storage plikÃ³w | âœ… Design ready | P0 (MVP) |
| **directory** | Lookup nadawcÃ³w (podmioty) | âœ… Design ready | P1 (post-MVP) |
| **auth** | User context, permissions | âœ… Implemented | P0 (MVP) |
| **audit** | Historia zmian (audit log) | âœ… Design ready | P1 (post-MVP) |
| **search** | Cmd+K global search | âœ… Implemented | P0 (MVP) |

**Kluczowe zasady integracji**:
- âŒ Brak foreign key constraints miÄ™dzy moduÅ‚ami (zasada izomorficznych moduÅ‚Ã³w)
- âœ… Snapshot danych z innych moduÅ‚Ã³w (nie runtime lookups)
- âœ… UUID jako identyfikatory (nie relacje ORM)
- âœ… Walidacja istnienia powiÄ…zanych rekordÃ³w w API (rÄ™czna)
- âœ… KaÅ¼dy moduÅ‚ tenant-scoped (tenantId + organizationId)

---

### F) Testy i jakoÅ›Ä‡
- **Q4-TEST-001 (P0)**: Jakie testy sÄ… wymagane dla generatora RPW?
  - test wspÃ³Å‚bieÅ¼noÅ›ci: 100 rÃ³wnoczesnych wywoÅ‚aÅ„ `register` â†’ sekwencja bez luk/duplikatÃ³w
  - test resetowania rocznie: czy sekwencja siÄ™ resetuje w Nowy Rok?
  - test rollback transakcji: czy failed `register` nie zuÅ¼y numeru z sekwencji?

- **Q4-TEST-002 (P1)**: Jak testujemy import CSV JRWA?
  - test przypadkÃ³w brzegowych: puste CSV, brak parent_code, cykliczne zaleÅ¼noÅ›ci
  - test duÅ¼ego importu (1000+ rekordÃ³w): performance, memory usage
  - test rollback przy bÅ‚Ä™dzie: czy transakcja wycofuje caÅ‚y import?

- **Q4-TEST-003 (P2)**: Czy potrzebujemy testÃ³w E2E dla UI?
  - test flow: utworzenie przesyÅ‚ki â†’ dodanie dokumentu â†’ rejestracja wpÅ‚ywu â†’ weryfikacja RPW
  - test walidacji: prÃ³ba rejestracji bez dokumentÃ³w â†’ bÅ‚Ä…d
  - test uprawnieÅ„: uÅ¼ytkownik bez `register` nie widzi przycisku "Zarejestruj wpÅ‚yw"

### G) Migracje i deployment
- **Q4-MIG-001 (P0)**: Jaka jest strategia migracji danych?
  - czy potrzebujemy seed data dla JRWA (domyÅ›lne klasy)?
  - czy potrzebujemy migracji dla istniejÄ…cych organizacji (inicjalizacja sekwencji RPW)?
  - czy deployment wymaga downtime (dodawanie indeksÃ³w na duÅ¼ych tabelach)?

- **Q4-MIG-002 (P1)**: Jak obsÅ‚ugujemy backward compatibility?
  - jeÅ›li zmienimy format RPW w przyszÅ‚oÅ›ci, jak obsÅ‚uÅ¼ymy stare numery?
  - czy stare przesyÅ‚ki bÄ™dÄ… miaÅ‚y flagÄ™ `legacy_rpw_format`?
  - czy API musi wspieraÄ‡ starsze wersje schematÃ³w?

### H) Dokumentacja i onboarding
- **Q4-DOC-USER-001 (P1)**: Czy potrzebujemy dokumentacji uÅ¼ytkownika dla moduÅ‚u `records`?
  - podrÄ™cznik: jak utworzyÄ‡ przesyÅ‚kÄ™, jak zarejestrowaÄ‡ wpÅ‚yw, jak wyszukiwaÄ‡
  - FAQ: najczÄ™stsze pytania uÅ¼ytkownikÃ³w
  - format: MDX w docs/ czy osobny system (Confluence, Notion)?

- **Q4-DOC-DEV-001 (P2)**: Czy aktualizujemy dokumentacjÄ™ developerskÄ…?
  - aktualizacja `docs/docs/domains/prawo/administracja-publiczna/mapping/openmercato-ezd/` z finalnymi decyzjami
  - dodanie przykÅ‚adÃ³w API payloadÃ³w (request/response)
  - diagram przepÅ‚ywu: draft â†’ registered (â†’ archived w przyszÅ‚oÅ›ci)

### I) PrzyszÅ‚e rozszerzenia (poza MVP)
- **Q4-FUTURE-001**: Czy sprawy i dokumenty wejdÄ… w kolejnym MVP?
  - relacja sprawaâ†”dokument
  - znak sprawy (generowanie, format, unikalnoÅ›Ä‡)
  - integracja z JRWA (sprawa ma klasÄ™ JRWA)

- **Q4-FUTURE-002**: Czy workflow (BPM) bÄ™dzie w module `records` czy osobny moduÅ‚?
  - workflow dla rejestracji przesyÅ‚ki (akceptacje, delegowanie)
  - workflow dla spraw (etapy, statusy, przejÅ›cia)
  - integracja z workflow engine (Camunda, Temporal)?

- **Q4-FUTURE-003**: Czy przesyÅ‚ki wychodzÄ…ce (RKW) wejdÄ… w MVP czy pÃ³Åºniej?
  - analogiczny model do przesyÅ‚ek wpÅ‚ywajÄ…cych
  - generator RKW (format, sekwencja)
  - relacja dokumentâ†’przesyÅ‚ka wychodzÄ…ca

---
## 14) Kryteria akceptacji (MVP)
- ModuÅ‚ `records` buduje siÄ™ i uruchamia bez migracji.
- API CRUD dziaÅ‚a (create/list/update/delete) dla obu zasobÃ³w w scope tenant/org.
- KaÅ¼dy route ma `openApi`.
- Search ma `formatResult` i nie pokazuje surowych UUID jako tytuÅ‚u.
- Backlog pytaÅ„ jest kompletny i gotowy do â€zamykaniaâ€ w kolejnych iteracjach.

---

## 15) PrzepÅ‚ywy uÅ¼ytkownika (User Flows)

:::info Cel sekcji
PoniÅ¼sze diagramy przepÅ‚ywÃ³w przedstawiajÄ… szczegÃ³Å‚owe Å›cieÅ¼ki uÅ¼ytkownika przez interfejs moduÅ‚u `records`. SÅ‚uÅ¼Ä… jako specyfikacja dla implementacji frontendu.
:::

### Flow 1: Rejestracja nowej przesyÅ‚ki wpÅ‚ywajÄ…cej (happy path)

```mermaid
graph TD
    A[Start: uÅ¼ytkownik w module Records] --> B{Ma uprawnienie<br/>manage?}
    B -->|Nie| C[Brak przycisku Nowa przesyÅ‚ka]
    B -->|Tak| D[Klik: Nowa przesyÅ‚ka]
    D --> E[Strona: /records/incoming-shipments/new]
    E --> F[Formularz w statusie draft]
    F --> G[WypeÅ‚nienie: Temat, Nadawca, SposÃ³b wpÅ‚ywu]
    G --> H[WybÃ³r: Kancelaria lookup organizational]
    H --> I[WybÃ³r: Data wpÅ‚ywu calendar]
    I --> J[Klik: Dodaj dokument]
    J --> K[Dialog: nowy dokument]
    K --> L[WypeÅ‚nienie: TytuÅ‚ dokumentu, Typ]
    L --> M[Optional: Upload zaÅ‚Ä…cznikÃ³w]
    M --> N[Klik: Zapisz dokument]
    N --> O[Dokument dodany do listy]
    O --> P{WiÄ™cej dokumentÃ³w?}
    P -->|Tak| J
    P -->|Nie| Q[Klik: Zapisz przesyÅ‚kÄ™]
    Q --> R[Walidacja: pola podstawowe OK]
    R --> S[API: POST /api/records/incoming-shipments]
    S --> T[Sukces: przesyÅ‚ka zapisana w draft]
    T --> U{Czy rejestrowaÄ‡ wpÅ‚yw?}
    U -->|Nie| V[Redirect: lista przesyÅ‚ek]
    U -->|Tak| W[Przycisk: Zarejestruj wpÅ‚yw widoczny]
    W --> X[Walidacja: dokumenty niepuste + wszystkie pola]
    X -->|BÅ‚Ä…d| Y[Komunikat: uzupeÅ‚nij wymagane]
    X -->|OK| Z[Klik: Zarejestruj wpÅ‚yw]
    Z --> AA[API: POST /api/.../id/register]
    AA --> AB[Sukces: nadanie RPW]
    AB --> AC[Flash: PrzesyÅ‚ka zarejestrowana RPW/XXX/00001/2026]
    AC --> AD[Status zmieniony: registered]
    AD --> AE[RPW visible, immutable]
    AE --> AF[Redirect: szczegÃ³Å‚y przesyÅ‚ki]
    AF --> AG[End]
```

### Flow 2: Edycja istniejÄ…cej przesyÅ‚ki

```mermaid
graph TD
    A[Start: lista przesyÅ‚ek] --> B[Klik: wiersz przesyÅ‚ki]
    B --> C[Strona: /records/incoming-shipments/id]
    C --> D{Uprawnienie<br/>manage?}
    D -->|Nie| E[Widok read-only]
    D -->|Tak| F[Widok edycji]
    F --> G[Pola edytowalne oprÃ³cz RPW]
    G --> H{Status = draft?}
    H -->|Tak| I[Przycisk Zarejestruj widoczny]
    H -->|Nie| J[Przycisk Zarejestruj ukryty]
    I --> K[Zmiana wartoÅ›ci pÃ³l]
    K --> L[Klik: Zapisz]
    L --> M[API: PUT /api/records/incoming-shipments]
    M --> N[Sukces: dane zaktualizowane]
    N --> O[Flash: PrzesyÅ‚ka zapisana]
    O --> P[Audit log: zmiana pÃ³l]
    P --> Q[End]
```

### Flow 3: Import CSV klas JRWA

```mermaid
graph TD
    A[Start: /records/jrwa-classes] --> B{Uprawnienie<br/>import?}
    B -->|Nie| C[Brak przycisku Import]
    B -->|Tak| D[Klik: Import CSV]
    D --> E[Strona: /records/jrwa-classes/import]
    E --> F[Etap 1: Upload]
    F --> G[Drag&drop lub wybÃ³r pliku CSV]
    G --> H[Plik wybrany]
    H --> I[Loading: Walidacja...]
    I --> J[API: POST /api/.../validate-csv]
    J --> K{BÅ‚Ä™dy walidacji?}
    K -->|Tak| L[Etap 2: Raport bÅ‚Ä™dÃ³w]
    L --> M[Lista bÅ‚Ä™dÃ³w: wiersz + opis]
    M --> N[Przycisk Import disabled]
    N --> O[Opcja: Pobierz raport CSV]
    O --> P[UÅ¼ytkownik poprawia plik]
    P --> F
    K -->|Nie| Q[Etap 3: Preview]
    Q --> R[Podsumowanie: X klas, Y nowych, Z aktualizacji]
    R --> S[PodglÄ…d pierwszych 10 wierszy]
    S --> T[Przycisk: Importuj enabled]
    T --> U[Klik: Importuj]
    U --> V[Etap 4: Import w toku]
    V --> W[Progress bar: X/Y]
    W --> X[API: POST /api/.../import]
    X --> Y[Sukces: import zakoÅ„czony]
    Y --> Z[Etap 5: Wynik]
    Z --> AA[Komunikat: Zaimportowano X klas]
    AA --> AB[Nowa wersja JRWA: version++]
    AB --> AC[Stara wersja: is_active=false]
    AC --> AD[Przycisk: WrÃ³Ä‡ do listy]
    AD --> AE[Redirect: /records/jrwa-classes]
    AE --> AF[End]
```

### Flow 4: Wyszukiwanie przesyÅ‚ek (Cmd+K)

```mermaid
graph TD
    A[Start: dowolna strona] --> B[Klawiatura: Cmd/Ctrl+K]
    B --> C[Modal: global search]
    C --> D[Input: wpisanie tekstu np RPW/001/00123/2026]
    D --> E[Search tokenization: subject, sender, RPW]
    E --> F[API: /api/search/query?q=...]
    F --> G[Wyniki: formatResult z records/search.ts]
    G --> H[Lista: ikona inbox + tytuÅ‚ subject + subtitle RPW]
    H --> I[Klik: wynik]
    I --> J[Redirect: /records/incoming-shipments/id]
    J --> K[End]
```

---

## 16) Checklist implementacji frontendu

:::warning Priorytet P0 - MVP
PoniÅ¼sza lista jest minimalnym zakresem implementacji UI dla MVP moduÅ‚u `records`. Wszystkie punkty muszÄ… byÄ‡ zrealizowane przed uznaniem moduÅ‚u za kompletny.
:::

### PrzesyÅ‚ki wpÅ‚ywajÄ…ce (Incoming Shipments)

#### Komponenty bazowe
- [ ] **IncomingShipmentForm.tsx** (CrudForm)
  - [ ] Definicja pÃ³l: subject, senderDisplayName, deliveryMethod, receivedAt, status
  - [ ] Pole lookup: receivingOrgUnitId â†’ organizational/org-units
  - [ ] Grupowanie w sekcje: Dane przesyÅ‚ki, Dane nadawcy, Dane rejestracji
  - [ ] Custom render: rpwNumber readonly (visible po rejestracji)
  - [ ] Walidacja: required fields zgodnie z schemas.ts

- [ ] **ShipmentDocumentsSection.tsx** (Embedded Section)
  - [ ] Lista dokumentÃ³w jako DataTable inline
  - [ ] Przycisk: Dodaj dokument (+ dropdown: nowy / nowy+plik)
  - [ ] Edit dokumentu w drawerze (nie modal)
  - [ ] Callback: onDocumentsChange dla sync z parent form
  - [ ] Walidacja: co najmniej 1 dokument dla rejestracji

- [ ] **ShipmentDocumentDialog.tsx** (Dialog/Drawer)
  - [ ] Pola: title, description, documentType
  - [ ] Sekcja: AttachmentsSection (upload plikÃ³w)
  - [ ] Submit: POST /api/records/documents
  - [ ] Loading state, error handling

- [ ] **RegisterShipmentButton.tsx** (Custom Action)
  - [ ] Visible tylko w status=draft
  - [ ] Disabled jeÅ›li !canRegister (walidacja)
  - [ ] API call: POST /api/.../id/register
  - [ ] Flash notification z RPW po sukcesie
  - [ ] Keyboard shortcut: Cmd/Ctrl+Enter

#### Strony (Pages)
- [ ] **frontend/incoming-shipments/page.tsx** (Lista)
  - [ ] DataTable z kolumnami: RPW, temat, nadawca, data wpÅ‚ywu, status
  - [ ] Filtry: status, data wpÅ‚ywu od/do, kancelaria
  - [ ] Search bar: temat, nadawca, RPW
  - [ ] Przycisk: Nowa przesyÅ‚ka (permission: manage)
  - [ ] RowActions: edit, delete (soft)

- [ ] **frontend/incoming-shipments/new/page.tsx** (Nowa)
  - [ ] IncomingShipmentForm w mode=create
  - [ ] DomyÅ›lny status: draft
  - [ ] Submit: POST /api/records/incoming-shipments
  - [ ] Redirect po zapisie: /incoming-shipments/[id]

- [ ] **frontend/incoming-shipments/[id]/page.tsx** (SzczegÃ³Å‚y/Edycja)
  - [ ] Layout sekcyjny: Dane przesyÅ‚ki, ZawartoÅ›Ä‡ (dokumenty), Historia
  - [ ] IncomingShipmentForm w mode=edit
  - [ ] ShipmentDocumentsSection embedded
  - [ ] RegisterShipmentButton (jeÅ›li draft)
  - [ ] Audit timeline (zakÅ‚adka Historia)
  - [ ] Submit: PUT /api/records/incoming-shipments

#### Integracje
- [ ] **Lookup: organizational/org-units**
  - [ ] LookupSelect z searchFields: name, symbol
  - [ ] onChange: snapshot receiving_org_unit_symbol
  
- [ ] **Lookup: directory/subjects** (opcjonalne)
  - [ ] LookupSelect dla nadawcy z opcjÄ… custom input
  - [ ] onChange: snapshot senderDisplayName, senderAddress

- [ ] **AttachmentsSection** (dla dokumentÃ³w)
  - [ ] Reuse z customers module
  - [ ] entityType=records_document

- [ ] **NotesSection** (dla notatek na przesyÅ‚ce)
  - [ ] Reuse z customers module
  - [ ] entityType=incoming_shipment

### JRWA Classes

#### Komponenty bazowe
- [ ] **JrwaClassForm.tsx** (CrudForm)
  - [ ] Pola: code, name, description, retentionCategory, archivalPackageVariant
  - [ ] Pole lookup: parentId â†’ JRWA classes (hierarchia)
  - [ ] Walidacja: unique (parent, code)

- [ ] **JrwaTreeNode.tsx** (Tree View)
  - [ ] Rekurencyjny component dla hierarchii
  - [ ] Expand/collapse children
  - [ ] onClick: redirect do szczegÃ³Å‚Ã³w
  - [ ] Visual: indentation by level

#### Strony (Pages)
- [ ] **frontend/jrwa-classes/page.tsx** (Lista/Drzewo)
  - [ ] Toggle: widok drzewa vs tabela
  - [ ] Widok drzewa: JrwaTreeView
  - [ ] Widok tabela: DataTable z kolumnami: kod, nazwa, retencja
  - [ ] Przycisk: Nowa klasa (permission: manage)
  - [ ] Przycisk: Import CSV (permission: import)

- [ ] **frontend/jrwa-classes/new/page.tsx** (Nowa)
  - [ ] JrwaClassForm w mode=create
  - [ ] Submit: POST /api/records/jrwa-classes

- [ ] **frontend/jrwa-classes/[id]/page.tsx** (SzczegÃ³Å‚y/Edycja)
  - [ ] JrwaClassForm w mode=edit
  - [ ] Submit: PUT /api/records/jrwa-classes
  - [ ] Lista dzieci (children) jako readonly table

- [ ] **frontend/jrwa-classes/import/page.tsx** (Import CSV)
  - [ ] Multi-step wizard: upload â†’ validate â†’ preview â†’ import â†’ result
  - [ ] Etap 1: UploadDropzone (.csv)
  - [ ] Etap 2: Walidacja (auto po upload)
  - [ ] Etap 3: Preview + raport bÅ‚Ä™dÃ³w
  - [ ] Etap 4: Progress bar (async import)
  - [ ] Etap 5: Wynik + redirect

### Dokumenty (Documents)

:::info Status
Encja `RecordsDocument` jest zdefiniowana w sekcji 5.3, ale nie zaimplementowana. PoniÅ¼szy checklist jest dla przyszÅ‚ej implementacji.
:::

- [ ] **RecordsDocument.entity.ts** (Backend)
  - [ ] Pola: title, description, documentType, attachmentIds
  - [ ] Relacja: shipmentId (via incoming_shipments.document_ids)

- [ ] **API routes** (Backend)
  - [ ] GET/POST/PUT/DELETE /api/records/documents
  - [ ] Walidacja: schemas.ts
  - [ ] OpenAPI: export openApi

- [ ] **DocumentForm.tsx** (Frontend)
  - [ ] UÅ¼ywany w ShipmentDocumentDialog
  - [ ] Integracja z AttachmentsSection

### Testy

**Uwaga**: PeÅ‚na dokumentacja strategii testowania dla integracji z eDoreczenia znajduje siÄ™ w [Dokumentacji implementacji integracji eDoreczenia](/docs/integracje/edoreczenia/implementation#testing-strategy).

#### A) Unit Tests

Testy jednostkowe dla moduÅ‚u `records` powinny byÄ‡ umieszczone w katalogach `__tests__` obok testowanego kodu.

**Lokalizacja**: `packages/core/src/modules/records/__tests__/`

##### A.1) Walidacja Zod Schemas

**Plik**: `validators.test.ts`

```typescript
describe('IncomingShipment Validation', () => {
  // Required Fields
  it('should validate required fields on create')
  it('should require subject, receivedAt, receivingOrgUnitId')
  it('should allow optional fields: postedAt, senderReference, documentDate')
  
  // Sender Validation (XOR logic)
  it('should accept senderId without senderDisplayName')
  it('should accept senderDisplayName without senderId')
  it('should reject when both senderId and senderDisplayName are missing')
  it('should allow both senderId and senderDisplayName together')
  
  // RPW Immutability
  it('should prevent rpwNumber modification on update')
  it('should prevent status change from registered to draft')
  it('should allow status change from draft to registered')
  
  // Date Validations
  it('should validate receivedAt is valid ISO date')
  it('should allow receivedAt in the past')
  it('should reject receivedAt in the future (optional business rule)')
  it('should validate postedAt <= receivedAt when both present')
  
  // Document IDs
  it('should validate documentIds as UUID array')
  it('should accept empty documentIds array')
  it('should reject invalid UUID format in documentIds')
  
  // Delivery Method
  it('should accept valid delivery methods (edoreczenia-mock, epuap, email, postal)')
  it('should reject invalid delivery methods')
  
  // Edge Cases
  it('should handle very long subject (should truncate or reject)')
  it('should handle special characters in sender name')
  it('should handle null vs undefined for optional fields')
})

describe('JrwaClass Validation', () => {
  // Required Fields
  it('should require code, name, organization')
  it('should validate code format (alphanumeric, dashes, dots)')
  
  // Hierarchy
  it('should allow null parentId for root classes')
  it('should validate parentId as UUID when provided')
  it('should prevent circular parent references')
  
  // Version Control
  it('should default version to 1 on create')
  it('should default isActive to true on create')
  
  // Unique Constraints
  it('should enforce unique (organization, parent_id, code)')
  it('should allow same code in different organizations')
  it('should allow same code with different parent')
})

describe('CSV Import Validation', () => {
  // File Format
  it('should validate CSV headers match expected format')
  it('should reject CSV with missing required columns')
  it('should handle different column order')
  
  // Data Validation
  it('should validate each row against JrwaClass schema')
  it('should collect all validation errors (not fail on first)')
  it('should provide line numbers for errors')
  
  // Hierarchy Validation
  it('should reject rows with non-existent parent_code')
  it('should detect circular dependencies')
  it('should validate topological order (parents before children)')
  
  // Edge Cases
  it('should handle empty CSV file')
  it('should handle CSV with only headers')
  it('should handle CSV with BOM (byte order mark)')
  it('should handle different line endings (CRLF, LF)')
})
```

##### A.2) Generator RPW

**Plik**: `rpw-generator.test.ts`

**OdpowiedÅº na Q4-TEST-001**:

```typescript
describe('RPW Number Generator', () => {
  // Format Validation
  it('should generate RPW in format: RPW/{symbol}/{seq:5}/{yyyy}')
  it('should pad sequence number to 5 digits')
  it('should use current year in format')
  
  // Uniqueness
  it('should generate unique RPW for same org unit and year')
  it('should not reuse RPW numbers')
  
  // Scoping
  it('should use organization + org unit symbol + year as scope')
  it('should allow same sequence in different org units')
  it('should allow same sequence in different years')
  it('should isolate sequences between organizations')
  
  // Sequence Management
  it('should start sequence at 1 for new scope')
  it('should increment sequence correctly')
  it('should find and reuse existing sequence entity')
  
  // Year Rollover
  it('should reset sequence to 1 on New Year')
  it('should maintain separate sequences for different years')
  it('should handle year change at midnight correctly')
  
  // Concurrency (Critical!)
  it('should handle 100 concurrent register calls without duplicates', async () => {
    const shipments = await createMultipleShipments(100)
    
    // Register all concurrently
    const registered = await Promise.all(
      shipments.map(s => registerShipment(s.id))
    )
    
    // Extract RPW numbers
    const rpwNumbers = registered.map(s => s.rpwNumber)
    
    // Verify no duplicates
    const uniqueRpw = new Set(rpwNumbers)
    expect(uniqueRpw.size).toBe(100)
    
    // Verify no gaps in sequence
    const sequences = rpwNumbers.map(rpw => {
      const match = rpw.match(/\/(\d{5})\//)
      return parseInt(match[1], 10)
    }).sort((a, b) => a - b)
    
    expect(sequences[0]).toBe(1)
    expect(sequences[99]).toBe(100)
  })
  
  // Transaction Rollback
  it('should not consume sequence number on failed registration', async () => {
    const shipment1 = await createShipment()
    const shipment2 = await createShipment()
    
    // Simulate registration failure for shipment1
    await expect(registerWithFailure(shipment1.id)).rejects.toThrow()
    
    // Register shipment2 successfully
    const registered = await registerShipment(shipment2.id)
    
    // Should get sequence 1 (not 2, because shipment1 failed)
    expect(registered.rpwNumber).toMatch(/\/00001\//)
  })
  
  // Performance
  it('should generate 1000 RPW numbers in < 5 seconds', async () => {
    const start = Date.now()
    await generateMultipleRpw(1000)
    const duration = Date.now() - start
    expect(duration).toBeLessThan(5000)
  })
  
  // Error Handling
  it('should throw error when org unit symbol is missing')
  it('should throw error when organization is missing')
  it('should handle database connection errors gracefully')
})
```

##### A.3) JRWA Import Logic

**Plik**: `jrwa-import.test.ts`

**OdpowiedÅº na Q4-TEST-002**:

```typescript
describe('JRWA CSV Import', () => {
  // Basic Import
  it('should import valid CSV with all classes')
  it('should create classes with correct hierarchy')
  it('should set version and isActive correctly')
  
  // Edge Cases
  it('should handle empty CSV file', async () => {
    const result = await importJrwaCsv('')
    expect(result.success).toBe(false)
    expect(result.errors).toContain('Empty file')
  })
  
  it('should handle CSV with only headers', async () => {
    const csv = 'code,name,parent_code\n'
    const result = await importJrwaCsv(csv)
    expect(result.success).toBe(true)
    expect(result.imported).toBe(0)
  })
  
  it('should reject CSV with missing parent_code reference', async () => {
    const csv = `code,name,parent_code
CLASS-1,Class 1,
CLASS-2,Class 2,NON-EXISTENT`
    const result = await importJrwaCsv(csv)
    expect(result.success).toBe(false)
    expect(result.errors).toContain('Parent code "NON-EXISTENT" not found')
  })
  
  it('should detect circular dependencies', async () => {
    const csv = `code,name,parent_code
CLASS-A,Class A,CLASS-B
CLASS-B,Class B,CLASS-A`
    const result = await importJrwaCsv(csv)
    expect(result.success).toBe(false)
    expect(result.errors).toContain('Circular dependency detected')
  })
  
  // Large Import Performance
  it('should import 1000+ records efficiently', async () => {
    const csv = generateLargeCsv(1000)
    const start = Date.now()
    
    const result = await importJrwaCsv(csv)
    
    const duration = Date.now() - start
    expect(result.success).toBe(true)
    expect(result.imported).toBe(1000)
    expect(duration).toBeLessThan(30000) // < 30 seconds
  })
  
  it('should not exceed memory limits with large CSV', async () => {
    const csv = generateLargeCsv(5000)
    const memBefore = process.memoryUsage().heapUsed
    
    await importJrwaCsv(csv)
    
    const memAfter = process.memoryUsage().heapUsed
    const memIncrease = (memAfter - memBefore) / 1024 / 1024 // MB
    expect(memIncrease).toBeLessThan(100) // < 100 MB
  })
  
  // Transaction Rollback
  it('should rollback entire import on error', async () => {
    const csv = `code,name,parent_code
CLASS-1,Class 1,
CLASS-2,Class 2,
INVALID,Invalid Class,` // This will fail due to some validation
    
    const countBefore = await countJrwaClasses()
    
    await expect(importJrwaCsv(csv)).rejects.toThrow()
    
    const countAfter = await countJrwaClasses()
    expect(countAfter).toBe(countBefore) // No partial import
  })
  
  // Versioning
  it('should increment version on reimport of existing classes')
  it('should deactivate old versions when importing new version')
  it('should maintain history of previous versions')
  
  // Duplicate Handling
  it('should update existing class if code matches')
  it('should create new version instead of overwriting')
})
```

#### B) Integration Tests

Testy integracyjne weryfikujÄ… interakcje miÄ™dzy moduÅ‚ami i systemem.

**Lokalizacja**: `packages/core/src/modules/records/api/__tests__/`

##### B.1) API Endpoints

**Plik**: `incoming-shipments.api.test.ts`

```typescript
describe('GET /api/records/incoming-shipments', () => {
  it('should return list of shipments for authenticated user')
  it('should filter by status (draft, registered, archived)')
  it('should filter by receivedAt date range')
  it('should filter by deliveryMethod')
  it('should sort by receivedAt desc by default')
  it('should support pagination (page, perPage)')
  it('should return 401 for unauthenticated requests')
  it('should return 403 without records.incoming_shipments.view permission')
  it('should filter by tenant and organization automatically')
})

describe('POST /api/records/incoming-shipments', () => {
  it('should create shipment with valid data')
  it('should set status to draft by default')
  it('should not allow setting rpwNumber on create')
  it('should validate required fields')
  it('should validate sender (senderId XOR senderDisplayName)')
  it('should return 400 for invalid data')
  it('should return 401 for unauthenticated requests')
  it('should return 403 without records.incoming_shipments.manage permission')
})

describe('PUT /api/records/incoming-shipments/:id', () => {
  it('should update shipment with valid data')
  it('should prevent rpwNumber modification')
  it('should prevent status change from registered to draft')
  it('should return 404 for non-existent shipment')
  it('should return 403 for shipments in other organizations')
})

describe('DELETE /api/records/incoming-shipments/:id', () => {
  it('should soft delete shipment')
  it('should set deletedAt timestamp')
  it('should not return deleted shipments in list')
  it('should prevent deletion of registered shipments (business rule)')
})

describe('POST /api/records/incoming-shipments/:id/register', () => {
  it('should assign RPW number to draft shipment')
  it('should change status to registered')
  it('should set registeredAt timestamp')
  it('should prevent registering already registered shipment')
  it('should prevent registering without required fields (documents)')
  it('should return 403 without records.incoming_shipments.register permission')
  it('should handle concurrent registration attempts gracefully')
})
```

**Plik**: `jrwa-classes.api.test.ts`

```typescript
describe('GET /api/records/jrwa-classes', () => {
  it('should return hierarchical list of JRWA classes')
  it('should filter by isActive')
  it('should filter by version')
  it('should support search by code or name')
  it('should return 401 for unauthenticated requests')
  it('should return 403 without records.jrwa_classes.view permission')
})

describe('POST /api/records/jrwa-classes', () => {
  it('should create new JRWA class')
  it('should validate unique (organization, parent_id, code)')
  it('should set version to 1 by default')
  it('should return 403 without records.jrwa_classes.manage permission')
})

describe('POST /api/records/jrwa-classes/import', () => {
  it('should import CSV file successfully')
  it('should validate CSV structure before import')
  it('should return validation errors with line numbers')
  it('should rollback on error')
  it('should return import statistics (imported, updated, errors)')
  it('should return 403 without records.jrwa_classes.import permission')
})
```

##### B.2) Database Operations

**Plik**: `database.test.ts`

```typescript
describe('RecordsIncomingShipment Entity', () => {
  it('should create shipment with all fields')
  it('should enforce foreign key constraints')
  it('should cascade soft delete to related entities')
  it('should update updatedAt on modification')
})

describe('RecordsRpwSequence Entity', () => {
  it('should create sequence with correct scope')
  it('should increment currentValue atomically')
  it('should handle concurrent increments correctly')
})

describe('RecordsJrwaClass Entity', () => {
  it('should create hierarchical structure')
  it('should prevent circular parent references')
  it('should enforce unique constraint')
  it('should maintain version history')
})
```

##### B.3) Integracja z moduÅ‚em correspondence_sources

**Plik**: `correspondence-integration.test.ts`

```typescript
describe('Correspondence Sources Integration', () => {
  it('should create shipment from correspondence sync')
  it('should map correspondence metadata correctly')
  it('should set deliveryMethod to source type')
  it('should set status to draft')
  it('should not assign RPW automatically')
  it('should include external ID in remarks')
  
  // Zobacz teÅ¼: /docs/integracje/edoreczenia/implementation#integration-tests
})
```

#### C) E2E Tests

Testy end-to-end weryfikujÄ… peÅ‚ne przepÅ‚ywy uÅ¼ytkownika.

**OdpowiedÅº na Q4-TEST-003**: Tak, testy E2E sÄ… wymagane dla krytycznych przepÅ‚ywÃ³w.

**Lokalizacja**: `tests/e2e/records/`

##### C.1) Rejestracja PrzesyÅ‚ki

**Plik**: `shipment-registration-flow.test.ts`

```typescript
describe('E2E: Shipment Registration Flow', () => {
  it('should complete full registration flow', async () => {
    // 1. Create draft shipment
    const shipment = await apiCall('POST', '/api/records/incoming-shipments', {
      subject: 'Test Document',
      receivedAt: new Date().toISOString(),
      receivingOrgUnitId: testOrgUnitId,
      senderDisplayName: 'Test Sender'
    })
    
    expect(shipment.status).toBe('draft')
    expect(shipment.rpwNumber).toBeNull()
    
    // 2. Add documents (when Phase 2 implemented)
    // await addDocuments(shipment.id, [...files])
    
    // 3. Register shipment (assign RPW)
    const registered = await apiCall('POST', `/api/records/incoming-shipments/${shipment.id}/register`)
    
    expect(registered.status).toBe('registered')
    expect(registered.rpwNumber).toMatch(/^RPW\/\w+\/\d{5}\/\d{4}$/)
    expect(registered.registeredAt).toBeTruthy()
    
    // 4. Verify in list
    const list = await apiCall('GET', '/api/records/incoming-shipments')
    const found = list.items.find(s => s.id === shipment.id)
    expect(found.status).toBe('registered')
  })
  
  it('should prevent registration without documents', async () => {
    const shipment = await createDraftShipment()
    
    await expect(
      apiCall('POST', `/api/records/incoming-shipments/${shipment.id}/register`)
    ).rejects.toMatchObject({
      status: 400,
      error: 'Cannot register shipment without documents'
    })
  })
  
  it('should respect permissions for registration', async () => {
    // User without register permission
    const userWithoutPermission = await createUserWithPermissions([
      'records.incoming_shipments.view',
      'records.incoming_shipments.manage'
    ])
    
    const shipment = await createDraftShipment()
    
    await expect(
      apiCallAsUser(
        'POST',
        `/api/records/incoming-shipments/${shipment.id}/register`,
        {},
        userWithoutPermission
      )
    ).rejects.toMatchObject({
      status: 403,
      error: 'Forbidden'
    })
  })
})
```

##### C.2) Import CSV JRWA

**Plik**: `jrwa-import-flow.test.ts`

```typescript
describe('E2E: JRWA CSV Import Flow', () => {
  it('should import valid CSV successfully', async () => {
    const csv = `code,name,parent_code,retention_category,archival_package_variant
CLASS-1,Class 1,,A,1
CLASS-1-1,Class 1.1,CLASS-1,B,2
CLASS-1-2,Class 1.2,CLASS-1,C,3`
    
    const result = await apiCall('POST', '/api/records/jrwa-classes/import', {
      csv,
      version: 2
    })
    
    expect(result.success).toBe(true)
    expect(result.imported).toBe(3)
    expect(result.errors).toHaveLength(0)
    
    // Verify classes created
    const classes = await apiCall('GET', '/api/records/jrwa-classes')
    expect(classes.items).toHaveLength(3)
  })
  
  it('should show validation errors for invalid CSV', async () => {
    const csv = `code,name,parent_code
CLASS-1,Class 1,NON-EXISTENT`
    
    const result = await apiCall('POST', '/api/records/jrwa-classes/import', {
      csv
    })
    
    expect(result.success).toBe(false)
    expect(result.errors).toContainEqual(
      expect.objectContaining({
        line: 2,
        message: expect.stringContaining('Parent code "NON-EXISTENT" not found')
      })
    )
  })
})
```

##### C.3) Integracja z eDoreczenia

**Plik**: `edoreczenia-integration-flow.test.ts`

```typescript
describe('E2E: eDoreczenia Integration Flow', () => {
  it('should sync correspondence and register shipment', async () => {
    // 1. Create correspondence source
    const source = await apiCall('POST', '/api/correspondence-sources/sources', {
      name: 'Test eDoreczenia',
      sourceType: 'edoreczenia-mock',
      config: {
        defaultReceivingOrgUnitId: testOrgUnitId,
        defaultReceivingOrgUnitSymbol: 'TEST'
      }
    })
    
    // 2. Create mock correspondence
    await apiCall('POST', '/api/correspondence-sources/edoreczenia-mock/correspondence', {
      subject: 'E2E Test Document',
      senderName: 'External Sender',
      receivedAt: new Date().toISOString(),
      documents: [{ filename: 'test.pdf', mimeType: 'application/pdf' }]
    })
    
    // 3. Trigger sync
    const syncResult = await apiCall('POST', `/api/correspondence-sources/sources/${source.id}/sync`)
    
    expect(syncResult.status).toBe('success')
    expect(syncResult.shipmentsCreated).toBe(1)
    
    // 4. Verify shipment created
    const shipments = await apiCall('GET', '/api/records/incoming-shipments')
    const shipment = shipments.items.find(s => s.subject === 'E2E Test Document')
    
    expect(shipment).toBeDefined()
    expect(shipment.status).toBe('draft')
    expect(shipment.deliveryMethod).toBe('edoreczenia-mock')
    
    // 5. Register shipment
    const registered = await apiCall('POST', `/api/records/incoming-shipments/${shipment.id}/register`)
    
    expect(registered.rpwNumber).toBeTruthy()
    expect(registered.status).toBe('registered')
  })
  
  // Zobacz teÅ¼: /docs/integracje/edoreczenia/implementation#e2e-tests
})
```

#### D) Performance Tests

**Lokalizacja**: `tests/performance/records/`

```typescript
describe('Performance: RPW Generation', () => {
  it('should handle 1000 concurrent registrations', async () => {
    const shipments = await createMultipleShipments(1000)
    const start = Date.now()
    
    await Promise.all(
      shipments.map(s => registerShipment(s.id))
    )
    
    const duration = Date.now() - start
    expect(duration).toBeLessThan(60000) // < 1 minute
  })
})

describe('Performance: JRWA Import', () => {
  it('should import 10,000 classes in reasonable time', async () => {
    const csv = generateLargeCsv(10000)
    const start = Date.now()
    
    await importJrwaCsv(csv)
    
    const duration = Date.now() - start
    expect(duration).toBeLessThan(120000) // < 2 minutes
  })
})
```

#### E) Test Coverage Goals

- **Unit Tests**: > 80% coverage
- **Integration Tests**: > 70% coverage
- **E2E Tests**: Cover all critical user journeys

#### F) Running Tests

```bash
# Run all tests
npm test

# Run specific module tests
npm test -- records

# Run specific test file
npm test -- rpw-generator.test.ts

# Run with coverage
npm test -- --coverage

# Run E2E tests only
npm test -- tests/e2e/records
```

#### G) Testing Tools

- **Jest**: Test framework (see `/jest.config.cjs`)
- **Supertest**: HTTP API testing
- **@faker-js/faker**: Test data generation
- **MikroORM**: Database transactions for test isolation

#### H) Best Practices

1. **Izolacja**: KaÅ¼dy test powinien byÄ‡ niezaleÅ¼ny
2. **Transakcje**: UÅ¼ywaj transakcji bazodanowych do rollbacku po testach
3. **Fixtures**: UÅ¼ywaj wspÃ³lnych fixtures dla testÃ³w
4. **AAA Pattern**: Arrange, Act, Assert
5. **CzytelnoÅ›Ä‡**: Nazwy testÃ³w powinny jasno opisywaÄ‡ co testujÄ…
6. **Edge Cases**: Testuj przypadki brzegowe i bÅ‚Ä™dy
7. **Performance**: Testy jednostkowe powinny byÄ‡ szybkie (< 100ms kaÅ¼dy)

### Dokumentacja uÅ¼ytkownika (opcjonalne)

- [ ] PodrÄ™cznik: jak utworzyÄ‡ przesyÅ‚kÄ™
- [ ] PodrÄ™cznik: jak zarejestrowaÄ‡ wpÅ‚yw
- [ ] PodrÄ™cznik: jak importowaÄ‡ JRWA
- [ ] FAQ: najczÄ™stsze pytania

---

## 17) Podsumowanie i next steps

### Co zostaÅ‚o osiÄ…gniÄ™te w tej dokumentacji?

âœ… **Kompletna analiza stanu implementacji**:
- Backend/API w 100% zaimplementowany
- Frontend/UI w 0% - wymagana peÅ‚na implementacja

âœ… **Wzorce UI/UX z istniejÄ…cych moduÅ‚Ã³w**:
- CrudForm, DataTable, Embedded Sections, Dialogs
- Konkretne przykÅ‚ady kodu (copy-paste ready)
- Podsumowanie: co skÄ…d wykorzystaÄ‡

âœ… **Integracje z innymi moduÅ‚ami**:
- organizational, attachments, directory, auth, audit, search
- API contracts, przykÅ‚ady implementacji
- Tabela integracji ze statusem i priorytetem

âœ… **PrzepÅ‚ywy uÅ¼ytkownika (User Flows)**:
- Mermaid diagramy dla 4 gÅ‚Ã³wnych scenariuszy
- Happy paths i edge cases

âœ… **Checklist implementacji frontendu**:
- Kompletna lista komponentÃ³w do zrealizowania
- Podzielona na moduÅ‚y: przesyÅ‚ki, JRWA, dokumenty
- Priorytetyzacja: P0 (MVP) vs post-MVP

### NastÄ™pne kroki

1. **Implementacja frontendu** (P0):
   - RozpoczÄ…Ä‡ od IncomingShipmentForm + lista + szczegÃ³Å‚y
   - NastÄ™pnie: ShipmentDocumentsSection + dialog
   - Na koÅ„cu: RegisterShipmentButton + walidacje

2. **JRWA UI** (P0):
   - Lista/drzewo klas
   - Import CSV (multi-step wizard)

3. **Encja Documents** (P1):
   - Implementacja RecordsDocument.entity.ts
   - API routes
   - Frontend integration

4. **Testy** (P1):
   - Unit tests dla schemas
   - Integration tests dla API
   - E2E tests dla user flows

5. **Dokumentacja uÅ¼ytkownika** (P2):
   - PodrÄ™czniki uÅ¼ytkowania
   - FAQ

### Otwarte pytania (Backlog Q4)

Backlog Q4 zawiera 30+ pytaÅ„ w kategoriach:
- A) Implementacja generatora RPW
- B) Dokumenty: szczegÃ³Å‚y implementacji
- C) Integracje moduÅ‚owe
- D) UI i UX (âœ… rozstrzygniÄ™te w tej wersji)
- E) Performance i indeksy
- F) Testy i jakoÅ›Ä‡
- G) Migracje i deployment
- H) Dokumentacja i onboarding
- I) PrzyszÅ‚e rozszerzenia (poza MVP)

Decyzje bÄ™dÄ… podejmowane iteracyjnie w trakcie implementacji.

---

**Koniec dokumentu analitycznego. Dokument gotowy do wykorzystania przez zespÃ³Å‚ implementacyjny.**
